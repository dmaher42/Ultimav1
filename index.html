<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Canvas RPG — Robust Sprite Loading (3×4 locked)</title>
  <style>
    html,body{margin:0;height:100%;background:#0a0f1f;color:#e5e7eb;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;overflow:hidden}
    #root{height:100%;position:relative}
    canvas{position:absolute;inset:0;display:block}
    .notice{position:fixed;top:10px;left:50%;transform:translateX(-50%);background:#111827cc;border:1px solid #243b55;border-radius:10px;padding:8px 12px;font:12px/1.4 ui-monospace,monospace;z-index:9999}
    .toolbar{position:fixed;right:10px;bottom:10px;background:#111827cc;border:1px solid #243b55;border-radius:10px;padding:8px 12px;font:12px/1.4 ui-monospace,monospace;z-index:9999;display:flex;gap:8px;align-items:center}
    .toolbar input[type="text"]{width:260px}
    .drop{position:fixed;inset:0;border:2px dashed #47556955;border-radius:12px;display:none;place-items:center;background:#0a0f1faa;color:#cbd5e1;font:14px/1.4 ui-monospace,monospace;z-index:9998}
    .drop.show{display:grid}
  </style>
</head>
<body>
  <div id="root">
    <canvas id="bg"></canvas>
    <canvas id="game" tabindex="0"></canvas>
  </div>

  <div id="notice" class="notice" style="display:none"></div>

  <div class="toolbar" style="opacity:0.95">
    <label>Sprite URL: <input id="spriteUrl" type="text" placeholder="Male 02.2.png or https://..." /></label>
    <button id="btnLoad">Load</button>
    <input id="fileInput" type="file" accept="image/png,image/jpeg" style="display:none" />
    <button id="btnFile">Choose File…</button>
    <select id="spriteSelect" style="margin-left:8px">
      <option value="Male 02-2.png">Male 02-2</option>
      <option value="Male 17-3.png">Male 17-3</option>
      <option value="Male 18-1.png">Male 18-1</option>
    </select>
  </div>
  <div id="drop" class="drop">Drop a PNG/JPG sprite sheet here (3 frames × 4 rows)</div>

  <script>
  const DEFAULT_WORLD={ width:1600, height:1200 };
  let currentWorld=null;
  function getActiveWorld(){ return currentWorld ?? DEFAULT_WORLD; }

  // ===== Canvas setup =====
  const dpr = Math.min(devicePixelRatio||1,2);
  const bgC = document.getElementById('bg');
  const gameC = document.getElementById('game');
  const bg = bgC.getContext('2d');
  const ctx = gameC.getContext('2d');

  // Global graphics configuration used by the toon pipeline.
  const DEFAULT_TONE_LEVELS=[0.0,0.55,1.0];
  const Graphics={
    pixelArtMode:false,
    renderScale:1,
    ambientDarkness:0.35,
    outlineColor:'#111',
    outlineThickness:1,
    toneLevels:[...DEFAULT_TONE_LEVELS],
    lights:[],
    playerLightEnabled:true,
    playerLightRadius:220,
    playerLightIntensity:0.85,
    sceneCanvas:document.createElement('canvas'),
    lightingCanvas:document.createElement('canvas'),
    _outlineBuffer:document.createElement('canvas')
  };
  Graphics.sceneCtx=Graphics.sceneCanvas.getContext('2d');
  Graphics.lightingCtx=Graphics.lightingCanvas.getContext('2d');
  Graphics._outlineCtx=Graphics._outlineBuffer.getContext('2d');

  function applyPixelArtSettings(){
    const smoothing=!Graphics.pixelArtMode;
    [ctx,bg,Graphics.sceneCtx,Graphics.lightingCtx,Graphics._outlineCtx].forEach(g=>{
      if(g) g.imageSmoothingEnabled=smoothing;
    });
  }

  function setLights(list){
    Graphics.lights=Array.isArray(list)?list.map(l=>({
      x:Number(l.x)||0,
      y:Number(l.y)||0,
      radius:Math.max(1,Number(l.radius)||0),
      intensity:Math.max(0,Math.min(1,Number(l.intensity ?? 1)))
    })) : [];
  }
  function setPixelArtMode(flag){
    Graphics.pixelArtMode=!!flag;
    applyPixelArtSettings();
  }
  function setAmbientDarkness(v){
    Graphics.ambientDarkness=Math.max(0,Math.min(1,Number(v)||0));
  }
  function setToneLevels(levels){
    if(!Array.isArray(levels)){
      Graphics.toneLevels=[...DEFAULT_TONE_LEVELS];
      return Graphics.toneLevels;
    }
    const sanitized=levels
      .map(value=>Number(value))
      .filter(value=>Number.isFinite(value))
      .map(value=>Math.max(0,Math.min(1,value)));
    Graphics.toneLevels=sanitized.length?sanitized:[...DEFAULT_TONE_LEVELS];
    return Graphics.toneLevels;
  }

  window.Graphics=Graphics;
  window.setLights=setLights;
  window.setPixelArtMode=setPixelArtMode;
  window.setAmbientDarkness=setAmbientDarkness;
  window.setToneLevels=setToneLevels;

  setToneLevels(Graphics.toneLevels);

  applyPixelArtSettings();

  // ===== Outline helpers =====
  const OUTLINE_OFFSETS_BASE=[[-1,0],[1,0],[0,-1],[0,1],[-1,-1],[1,-1],[-1,1],[1,1]];
  function snapPixel(v){ return Graphics.pixelArtMode?Math.round(v):v; }
  function getEffectiveOutlineThickness(thickness){
    const base=Math.max(0.5,Number(thickness)||0);
    const darknessBoost=Graphics.ambientDarkness>0.5?1:0;
    return base+darknessBoost;
  }

  function ensureOutlineBufferSize(width,height){
    const canvas=Graphics._outlineBuffer;
    const targetW=Math.max(width,1);
    const targetH=Math.max(height,1);
    if(canvas.width<targetW) canvas.width=targetW;
    if(canvas.height<targetH) canvas.height=targetH;
    Graphics._outlineCtx.setTransform(1,0,0,1,0,0);
  }

  function drawOutlinedSprite(targetCtx,image,sx,sy,sw,sh,dx,dy,dw=sw,dh=sh,outlineColor=Graphics.outlineColor,thickness=Graphics.outlineThickness){
    if(!image) return;
    const color=outlineColor ?? Graphics.outlineColor;
    const t=getEffectiveOutlineThickness(thickness);
    const offset=Graphics.pixelArtMode?Math.max(1,Math.round(t)):t;
    const pad=offset+2;
    const offW=Math.ceil(dw+pad*2);
    const offH=Math.ceil(dh+pad*2);
    ensureOutlineBufferSize(offW,offH);
    const octx=Graphics._outlineCtx;
    octx.save();
    octx.clearRect(0,0,offW,offH);
    octx.imageSmoothingEnabled=!Graphics.pixelArtMode;
    octx.drawImage(image,sx,sy,sw,sh,pad,pad,dw,dh);
    octx.globalCompositeOperation='source-in';
    octx.fillStyle=color;
    octx.fillRect(0,0,offW,offH);
    octx.globalCompositeOperation='source-over';
    octx.restore();

    const baseX=snapPixel(dx-pad);
    const baseY=snapPixel(dy-pad);
    for(const [ox,oy] of OUTLINE_OFFSETS_BASE){
      const px=Graphics.pixelArtMode?snapPixel(baseX+ox*offset):baseX+ox*offset;
      const py=Graphics.pixelArtMode?snapPixel(baseY+oy*offset):baseY+oy*offset;
      targetCtx.drawImage(Graphics._outlineBuffer,0,0,offW,offH,px,py,offW,offH);
    }
    targetCtx.drawImage(image,sx,sy,sw,sh,snapPixel(dx),snapPixel(dy),dw,dh);
  }

  function drawOutlinedRect(targetCtx,x,y,w,h,color,outlineColor=Graphics.outlineColor,thickness=Graphics.outlineThickness){
    const t=getEffectiveOutlineThickness(thickness);
    const offset=Graphics.pixelArtMode?Math.max(1,Math.round(t)):t;
    const pad=offset+2;
    const offW=Math.ceil(w+pad*2);
    const offH=Math.ceil(h+pad*2);
    ensureOutlineBufferSize(offW,offH);
    const octx=Graphics._outlineCtx;
    const outline=outlineColor ?? Graphics.outlineColor;
    octx.save();
    octx.clearRect(0,0,offW,offH);
    octx.fillStyle='#fff';
    octx.fillRect(pad,pad,w,h);
    octx.globalCompositeOperation='source-in';
    octx.fillStyle=outline;
    octx.fillRect(0,0,offW,offH);
    octx.globalCompositeOperation='source-over';
    octx.restore();

    const baseX=snapPixel(x-pad);
    const baseY=snapPixel(y-pad);
    for(const [ox,oy] of OUTLINE_OFFSETS_BASE){
      const px=Graphics.pixelArtMode?snapPixel(baseX+ox*offset):baseX+ox*offset;
      const py=Graphics.pixelArtMode?snapPixel(baseY+oy*offset):baseY+oy*offset;
      targetCtx.drawImage(Graphics._outlineBuffer,0,0,offW,offH,px,py,offW,offH);
    }
    targetCtx.fillStyle=color;
    targetCtx.fillRect(snapPixel(x),snapPixel(y),w,h);
  }

  let currentRoom=null;          // currently active room definition
  const currentObstacles=[];     // obstacles for collision/rendering
  const currentProps=[];         // decorative props for the current room
  let currentParallaxLayers=[];  // parallax layers per room (defaults later)
  let camera=null;
  function resize(){
    const scale=Math.max(0.25, Number(Graphics.renderScale)||1);
    const screenW=innerWidth*dpr;
    const screenH=innerHeight*dpr;

    bgC.width=screenW;
    bgC.height=screenH;
    bg.setTransform(dpr,0,0,dpr,0,0);

    gameC.width=screenW;
    gameC.height=screenH;
    ctx.setTransform(dpr,0,0,dpr,0,0);

    const offW=Math.max(1,Math.round(screenW*scale));
    const offH=Math.max(1,Math.round(screenH*scale));
    if(Graphics.sceneCanvas.width!==offW || Graphics.sceneCanvas.height!==offH){
      Graphics.sceneCanvas.width=offW;
      Graphics.sceneCanvas.height=offH;
    }
    if(Graphics.lightingCanvas.width!==offW || Graphics.lightingCanvas.height!==offH){
      Graphics.lightingCanvas.width=offW;
      Graphics.lightingCanvas.height=offH;
    }
    Graphics.sceneCtx.setTransform(dpr*scale,0,0,dpr*scale,0,0);
    Graphics.lightingCtx.setTransform(dpr*scale,0,0,dpr*scale,0,0);

    applyPixelArtSettings();

    drawBackground();

    if(camera){
      resizeCamera();
      clampCameraToWorld(camera, camera.width, camera.height, getActiveWorld());
    }
  }
  addEventListener('resize',resize);
  function drawBackground(){ const g=bg.createLinearGradient(0,0,0,innerHeight); g.addColorStop(0,'#1a2b45'); g.addColorStop(1,'#0b1326'); bg.fillStyle=g; bg.fillRect(0,0,innerWidth,innerHeight); }

  // ===== UI notice helper =====
  const noticeEl = document.getElementById('notice');
  function showNotice(msg){ noticeEl.textContent=msg; noticeEl.style.display='block'; clearTimeout(showNotice._t); showNotice._t=setTimeout(()=>noticeEl.style.display='none',7000); }
  function getParam(name){ const u=new URL(location.href); return u.searchParams.get(name); }

  // ===== Sprite loading (robust) =====
  // Layout is permanently locked: 4 rows (down,left,right,up) × 3 columns (frames)
  const SHEET_COLS = 3, SHEET_ROWS = 4;
  const DIR_ROW={ down:0, left:1, right:2, up:3 };

  // Put sprite PNG files inside public/assets/ so the loader can find them by name.
  const SPRITE_BASE_PATH='public/assets/';
  const SPRITE_NAME_ALIASES={
    'sprite-0002.png':'Male 02-2.png',
    'sprite-0002':'Male 02-2.png',
    'male 02-2.png':'Male 02-2.png',
    'male 02-2':'Male 02-2.png',
    'male 02.2.png':'Male 02-2.png',
    'male 02.2':'Male 02-2.png',
    'male 18-1.png':'Male 18-1.png',
    'male 18-1':'Male 18-1.png',
    'soldier 01-1.png':'Soldier 01-1.png',
    'soldier 01-1':'Soldier 01-1.png'
  };
  function embedPngBase64(chunks){
    if(!Array.isArray(chunks)) return null;
    return 'data:image/png;base64,' + chunks.join('');
  }
  const EMBEDDED_SPRITES=Object.freeze({
    'Male 02-2.png': embedPngBase64([
      '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'
    ]),
    'Male 18-1.png': embedPngBase64([
      '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',
      'js7U7G9JTvkPdWLxVHHt7m0AAAAASUVORK5CYII='
    ]),
    'Soldier 01-1.png': embedPngBase64([
      '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',
      'P2jIfkIszWpTAAAAAElFTkSuQmCC'
    ])
  });
  const SPRITES=Object.create(null);

  window.SPRITES=SPRITES;
  window.EMBEDDED_SPRITES=EMBEDDED_SPRITES;

  let activeSpriteName='';
  let spriteReady=false;    // ready flag for the active sprite
  let frameW=32, frameH=32; // computed on load
  let currentObjectUrl=null;// revoke blob URLs when replaced

  const spriteReadyResolvers=[];
  function resolveSpriteWaiters(){
    while(spriteReadyResolvers.length){
      const resolve=spriteReadyResolvers.shift();
      try{ resolve(SPRITES[activeSpriteName] ?? null); }
      catch(err){ console.error('Sprite ready callback failed', err); }
    }
  }
  function waitForSpriteReady(){
    if(spriteReady) return Promise.resolve(SPRITES[activeSpriteName] ?? null);
    return new Promise(resolve=>spriteReadyResolvers.push(resolve));
  }

  function placeholderColorFor(name){
    const palette=['#38bdf8','#f97316','#f472b6','#facc15','#34d399','#a855f7'];
    let hash=0;
    for(let i=0;i<name.length;i++){
      hash=(hash*31 + name.charCodeAt(i))|0;
    }
    const index=Math.abs(hash)%palette.length;
    return palette[index];
  }

  function createPlaceholderSheet(name){
    const cellSize=48;
    const width=SHEET_COLS*cellSize;
    const height=SHEET_ROWS*cellSize;
    const canvas=document.createElement('canvas');
    canvas.width=width;
    canvas.height=height;
    const g=canvas.getContext('2d');
    const color=placeholderColorFor(name);
    g.fillStyle=color;
    g.fillRect(0,0,width,height);
    g.strokeStyle='#0f172a';
    g.lineWidth=4;
    g.strokeRect(2,2,width-4,height-4);
    g.strokeStyle='#1e293b';
    g.lineWidth=1;
    for(let c=1;c<SHEET_COLS;c++){
      const x=c*cellSize;
      g.beginPath();
      g.moveTo(x,2);
      g.lineTo(x,height-2);
      g.stroke();
    }
    for(let r=1;r<SHEET_ROWS;r++){
      const y=r*cellSize;
      g.beginPath();
      g.moveTo(2,y);
      g.lineTo(width-2,y);
      g.stroke();
    }
    return { image:canvas, color, cellSize };
  }

  function resolveSpriteAlias(name,url){
    if(url) return { name, changed:false };
    const baseName=typeof name==='string'?name:'';
    const normalized=baseName.toLowerCase();
    const alias=SPRITE_NAME_ALIASES[normalized];
    if(alias){
      return { name:alias, changed:true };
    }
    return { name:baseName, changed:false };
  }

  function getSpriteSource(name,url){
    if(url) return url;
    const resolved=resolveSpriteAlias(name,url);
    const canonicalName=resolved?.name ?? name;
    const embedded=EMBEDDED_SPRITES[canonicalName];
    if(embedded){
      return embedded;
    }
    const base=SPRITE_BASE_PATH.endsWith('/')?SPRITE_BASE_PATH:(SPRITE_BASE_PATH+'/');
    return base+canonicalName;
  }

  function finalizeSpriteLoad(name,image,options={}){
    const width=image.naturalWidth || image.width || (SHEET_COLS*32);
    const height=image.naturalHeight || image.height || (SHEET_ROWS*32);
    const frameWidth=Math.max(1,Math.floor(width/SHEET_COLS));
    const frameHeight=Math.max(1,Math.floor(height/SHEET_ROWS));
    const entry={
      name,
      image,
      width,
      height,
      frameWidth,
      frameHeight,
      placeholder:!!options.placeholder,
      placeholderColor:options.color ?? null
    };
    SPRITES[name]=entry;
    if(name===activeSpriteName){
      frameW=frameWidth;
      frameH=frameHeight;
      spriteReady=true;
      resolveSpriteWaiters();
      if(typeof updatePlayerCollider==='function'){
        try{ updatePlayerCollider(); }
        catch(err){ console.error('updatePlayerCollider failed', err); }
      }
      if(entry.placeholder){
        showNotice(`Placeholder active for ${name}. Check console for details.`);
      } else {
        showNotice(`Loaded sprite: ${name}`);
      }
    }
    return entry;
  }

  function loadSprite(name,url){
    const source=getSpriteSource(name,url);
    return new Promise(resolve=>{
      const img=new Image();
      img.decoding='async';
      img.crossOrigin='anonymous';
      img.onload=()=>{
        const entry=finalizeSpriteLoad(name,img,{ placeholder:false });
        resolve(entry);
      };
      img.onerror=(err)=>{
        console.error(`Sprite "${name}" failed to load from ${source}. Using placeholder rectangle instead.`, err);
        const placeholder=createPlaceholderSheet(name);
        const entry=finalizeSpriteLoad(name,placeholder.image,{ placeholder:true, color:placeholder.color });
        resolve(entry);
      };
      img.src=source;
    });
  }
  window.loadSprite=loadSprite;

  function setActiveSprite(name,url){
    const resolved=resolveSpriteAlias(name,url);
    const effectiveName=resolved?.name ?? name;
    if(currentObjectUrl && currentObjectUrl!==url){ URL.revokeObjectURL(currentObjectUrl); currentObjectUrl=null; }
    if(url && url.startsWith('blob:')){ currentObjectUrl=url; }
    activeSpriteName=effectiveName;
    spriteReady=false;
    return loadSprite(effectiveName,url);
  }

  function parseSpriteInput(value){
    if(!value) return null;
    const trimmed=value.trim();
    if(!trimmed) return null;
    const isProtocol=/^(https?:|data:|blob:)/i.test(trimmed);
    const looksLikePath=trimmed.startsWith('/') || trimmed.startsWith('./') || trimmed.startsWith('../') || trimmed.includes('/');
    if(isProtocol || looksLikePath){
      const namePart=trimmed.split(/[\\/]/).pop() || trimmed;
      const cleanName=namePart.split('?')[0] || namePart;
      return { name:cleanName, url:trimmed };
    }
    return { name:trimmed, url:null };
  }

  function setActiveSpriteFromValue(raw,{ save=false }={}){
    const parsed=parseSpriteInput(raw);
    if(!parsed) return;
    const resolved=resolveSpriteAlias(parsed.name, parsed.url);
    const effectiveName=resolved?.name ?? parsed.name;
    const effectiveUrl=parsed.url;
    const effectiveValue=effectiveUrl || effectiveName;
    if(save){
      if(effectiveUrl && effectiveUrl.startsWith('blob:')){
        localStorage.removeItem('spriteURL');
      } else {
        localStorage.setItem('spriteURL', effectiveValue);
      }
    }
    const promise=setActiveSprite(effectiveName, effectiveUrl);
    if(promise && typeof promise==='object'){
      promise.effectiveValue=effectiveValue;
      promise.resolvedName=effectiveName;
      promise.resolvedUrl=effectiveUrl;
    }
    return promise;
  }

  const qp=getParam('sprite');
  const saved=localStorage.getItem('spriteURL');
  const DEFAULT_SPRITE_NAME='Male 02-2.png';
  const initialValue=qp || saved || DEFAULT_SPRITE_NAME;

  const initialSpritePromise=waitForSpriteReady();
  const initialSelection=setActiveSpriteFromValue(initialValue);

  const urlInput=document.getElementById('spriteUrl');
  urlInput.value=initialSelection?.effectiveValue ?? initialValue;

  document.getElementById('btnLoad').onclick=()=>{
    const raw=urlInput.value.trim();
    if(!raw) return;
    const selection=setActiveSpriteFromValue(raw,{ save:true });
    if(selection?.effectiveValue){
      urlInput.value=selection.effectiveValue;
    }
    if(spriteSelect && selection?.resolvedName){
      for(const opt of spriteSelect.options){
        if(opt.value===selection.resolvedName){
          spriteSelect.value=selection.resolvedName;
          break;
        }
      }
    }
  };

  const spriteSelect=document.getElementById('spriteSelect');
  if(spriteSelect){
    const parsedInitial=parseSpriteInput(initialSelection?.resolvedName || initialValue);
    const initialAlias=parsedInitial?resolveSpriteAlias(parsedInitial.name, parsedInitial.url):null;
    const initialName=initialAlias?.name;
    if(initialName){
      for(const opt of spriteSelect.options){
        if(opt.value===initialName){
          spriteSelect.value=opt.value;
          break;
        }
      }
    }
    spriteSelect.addEventListener('change',()=>{
      const choice=spriteSelect.value;
      urlInput.value=choice;
      const selection=setActiveSpriteFromValue(choice,{ save:true });
      if(selection?.effectiveValue){
        urlInput.value=selection.effectiveValue;
      }
      if(selection?.resolvedName){
        for(const opt of spriteSelect.options){
          if(opt.value===selection.resolvedName){
            spriteSelect.value=selection.resolvedName;
            break;
          }
        }
      }
    });
  }

  const fileInput=document.getElementById('fileInput');
  document.getElementById('btnFile').onclick=()=>fileInput.click();
  fileInput.onchange=()=>{
    const f=fileInput.files && fileInput.files[0];
    if(!f) return;
    const objectUrl=URL.createObjectURL(f);
    urlInput.value=f.name;
    // Reminder: copy sprites into public/assets/ for persistent loads instead of blob URLs.
    setActiveSprite(f.name, objectUrl);
  };

  const drop=document.getElementById('drop');
  ['dragenter','dragover'].forEach(ev=>addEventListener(ev,e=>{e.preventDefault(); drop.classList.add('show');}));
  ['dragleave','drop'].forEach(ev=>addEventListener(ev,e=>{
    e.preventDefault();
    if(ev==='drop'){
      const f=e.dataTransfer.files && e.dataTransfer.files[0];
      if(f){
        const objectUrl=URL.createObjectURL(f);
        urlInput.value=f.name;
        // Reminder: copy sprites into public/assets/ for persistent loads instead of blob URLs.
        setActiveSprite(f.name, objectUrl);
      }
    }
    drop.classList.remove('show');
  }));

  // ===== Player, input, animation (3×4 locked) =====
  const player={
    x:200,
    y:200,
    speed:200,
    frame:1,
    dir:'down',
    tick:0,
    collider:{ w:24, h:28 },
    state:'idle',
    wasMoving:false,
    outlineColor:'#070b16',
    outlineThickness:1.5
  };
  const particles=[];
  const pressed=new Set();
  function normKey(k){ const map={Left:'ArrowLeft',Right:'ArrowRight',Up:'ArrowUp',Down:'ArrowDown'}; return map[k] || (k.length===1?k.toLowerCase():k); }
  // Global keybinds: WASD/arrow for movement, 'N' jumps to the next room.
  addEventListener('keydown',e=>{
    const k=normKey(e.key);
    if(k==='n'){
      if(!e.repeat){
        e.preventDefault();
        goToNextRoom();
      }
      return;
    }
    if(k.startsWith('Arrow')) e.preventDefault();
    pressed.add(k);
  });
  addEventListener('keyup',e=>{ const k=normKey(e.key); if(k.startsWith('Arrow')) e.preventDefault(); pressed.delete(k); });

  function frameRect(dir,frame){
    const row={down:0,left:1,right:2,up:3}[dir];
    const col=Math.max(0,Math.min(SHEET_COLS-1, frame));
    return { sx:col*frameW, sy:row*frameH, sw:frameW, sh:frameH };
  }

  function updatePlayerCollider(){
    // Shrink the collision box so the player feels responsive.
    player.collider.w=Math.max(18,Math.min(frameW*0.6, frameW));
    player.collider.h=Math.max(20,Math.min(frameH*0.7, frameH));
  }
  waitForSpriteReady().then(updatePlayerCollider);

  // ===== Camera setup =====
  camera={
    x:0,
    y:0,
    width:innerWidth,
    height:innerHeight,
    deadzone:{ width:360, height:220 }
  };

  function resizeCamera(){
    if(!camera) return;
    camera.width=innerWidth;
    camera.height=innerHeight;
  }
  resize();

  // ===== World data & loading =====
  const propSpriteCache=new Map();
  function requestPropSprite(url){
    const key=url||'';
    if(!propSpriteCache.has(key)){
      const img=new Image();
      img.decoding='async';
      img.crossOrigin='anonymous';
      const entry={ img, ready:false, error:false };
      const parsed=parseSpriteInput(url);
      let source=url;
      if(parsed){
        const resolved=resolveSpriteAlias(parsed.name, parsed.url);
        const canonical=resolved?.name ?? parsed.name;
        const embedded=EMBEDDED_SPRITES[canonical];
        const legacyPath=typeof parsed.url==='string' && /^\.?\/?assets\//i.test(parsed.url);
        if(embedded){
          source=embedded;
        } else if(!parsed.url || legacyPath){
          const base=SPRITE_BASE_PATH.endsWith('/')?SPRITE_BASE_PATH:(SPRITE_BASE_PATH+'/');
          source=base+canonical;
        } else {
          source=parsed.url;
        }
      }
      img.onload=()=>{ entry.ready=true; };
      img.onerror=()=>{ entry.error=true; };
      img.src=source || url;
      propSpriteCache.set(key,entry);
    }
    return propSpriteCache.get(key);
  }

  function createDefaultParallaxLayers(){
    return [
      { factor:0.1, type:'gradient', colors:['#0b1326','#0f172a'] },
      { factor:0.3, type:'hills', color:'#10203a', base:260, amplitude:90, spacing:420 },
      { factor:0.55, type:'hills', color:'#1a2f4f', base:320, amplitude:60, spacing:260 },
      { factor:0.85, type:'foreground', color:'#1f3b5f', height:160 }
    ];
  }

  function cloneObstacles(list){
    return (list||[]).map(o=>({
      x:Number(o.x)||0,
      y:Number(o.y)||0,
      w:Number(o.w)||0,
      h:Number(o.h)||0,
      type:o.type||'wall'
    }));
  }

  function cloneProps(list){
    return (list||[]).map(p=>({
      x:Number(p.x)||0,
      y:Number(p.y)||0,
      w:Number(p.w)||32,
      h:Number(p.h)||32,
      color:p.color||'#94a3b8',
      spriteURL:p.spriteURL||null,
      sprite:null,
      shadow:typeof p.shadow==='boolean'?p.shadow:undefined,
      height:Number(p.height)||0,
      outlineColor:p.outlineColor||null,
      outlineThickness:typeof p.outlineThickness==='number'?p.outlineThickness:null,
      type:p.type||null,
      handleColor:p.handleColor||null,
      flameColor:p.flameColor||null,
      flameHighlight:p.flameHighlight||null,
      glowColor:p.glowColor||null,
      sconceColor:p.sconceColor||null,
      lightRadius:Number.isFinite(Number(p.lightRadius))?Number(p.lightRadius):null,
      lightIntensity:Number.isFinite(Number(p.lightIntensity))?Number(p.lightIntensity):null,
      lightOffsetY:Number.isFinite(Number(p.lightOffsetY))?Number(p.lightOffsetY):null
    }));
  }

  function deriveTorchLights(list){
    if(!Array.isArray(list)) return [];
    const lights=[];
    for(const prop of list){
      if(!prop || prop.type!=='torch') continue;
      const width=Math.max(0,Number(prop.w)||0);
      const height=Math.max(0,Number(prop.h)||0);
      const rawRadius=Number(prop.lightRadius);
      const rawIntensity=Number(prop.lightIntensity);
      const rawOffset=Number(prop.lightOffsetY);
      const radius=Number.isFinite(rawRadius)?Math.max(1,rawRadius):Math.max(160,height*3);
      const intensity=Number.isFinite(rawIntensity)?Math.max(0,Math.min(1,rawIntensity)):0.88;
      const offset=Math.max(0,Number.isFinite(rawOffset)?rawOffset:height*0.3);
      lights.push({
        x:prop.x+width/2,
        y:prop.y+offset,
        radius,
        intensity
      });
    }
    return lights;
  }

  // ----- Room definitions (edit/add rooms here) -----
  const rooms={
    room1:{
      spawn:{ x:320, y:360 },
      obstacles:[
        { x:180, y:200, w:420, h:48, type:'wall' },
        { x:680, y:420, w:96, h:180, type:'tree' },
        { x:520, y:620, w:260, h:56, type:'rock' }
      ],
      props:[
        { x:520, y:260, w:48, h:48, spriteURL:'assets/Male 18-1.png', shadow:true, height:24 },
        { x:860, y:480, w:40, h:40, color:'#64748b', shadow:true },
        // Example wall torches with automatic lighting
        { type:'torch', x:340, y:260, w:18, h:62, shadow:false, handleColor:'#6b3f1d', sconceColor:'#3f4d63', flameColor:'#fb923c', flameHighlight:'#fef3c7', glowColor:'rgba(253,224,171,0.4)', lightRadius:240, lightIntensity:0.9, lightOffsetY:24 },
        { type:'torch', x:820, y:260, w:18, h:62, shadow:false, handleColor:'#6b3f1d', sconceColor:'#3f4d63', flameColor:'#f97316', flameHighlight:'#fde68a', glowColor:'rgba(253,224,171,0.35)', lightRadius:240, lightIntensity:0.92, lightOffsetY:24 }
      ],
      lights:[
        { x:420, y:340, radius:280, intensity:0.85 },
        { x:760, y:500, radius:240, intensity:0.8 }
      ]
    },
    room2:{
      spawn:{ x:720, y:420 },
      obstacles:[
        { x:260, y:340, w:520, h:60, type:'wall' },
        { x:940, y:360, w:140, h:220, type:'tree' },
        { x:540, y:740, w:360, h:70, type:'rock' }
      ],
      props:[
        { x:600, y:520, w:60, h:60, color:'#475569', shadow:true },
        { x:1040, y:360, w:96, h:96, spriteURL:'assets/Male 18-1.png', shadow:true, height:36 },
        // Torches flank the entrance in this room as well
        { type:'torch', x:520, y:320, w:18, h:60, shadow:false, handleColor:'#6b3f1d', sconceColor:'#3f4d63', flameColor:'#fb923c', flameHighlight:'#fef3c7', glowColor:'rgba(253,224,171,0.38)', lightRadius:220, lightIntensity:0.88, lightOffsetY:22 },
        { type:'torch', x:980, y:320, w:18, h:60, shadow:false, handleColor:'#6b3f1d', sconceColor:'#3f4d63', flameColor:'#f97316', flameHighlight:'#fde68a', glowColor:'rgba(253,224,171,0.34)', lightRadius:220, lightIntensity:0.9, lightOffsetY:22 }
      ],
      lights:[
        { x:720, y:400, radius:260, intensity:0.9 },
        { x:1080, y:360, radius:220, intensity:0.7 }
      ]
    }
  };

  const roomNames=Object.keys(rooms);
  let currentRoomIndex=0;

  // Loader entry point: pass in a plain JS room object (e.g., parsed JSON).
  function loadRoom(roomData){
    if(!roomData) return;

    // Cache spawn so we can position the player before starting the loop.
    const spawn={
      x:Number(roomData.spawn?.x) || 0,
      y:Number(roomData.spawn?.y) || 0
    };

    // Clear old state and copy in the new room geometry.
    currentObstacles.length=0;
    currentProps.length=0;
    currentObstacles.push(...cloneObstacles(roomData.obstacles));

    const props=cloneProps(roomData.props);
    for(const prop of props){
      if(prop.spriteURL){
        prop.sprite=requestPropSprite(prop.spriteURL);
      }
      currentProps.push(prop);
    }

    currentParallaxLayers = roomData.parallaxLayers?.length
      ? roomData.parallaxLayers.map(layer=>({ ...layer }))
      : createDefaultParallaxLayers();

    const baseLights=Array.isArray(roomData.lights)?roomData.lights:[];
    const torchLights=deriveTorchLights(currentProps); // auto lights for torches
    setLights([...baseLights,...torchLights]);

    currentWorld={
      width:roomData.world?.width ?? DEFAULT_WORLD.width,
      height:roomData.world?.height ?? DEFAULT_WORLD.height
    };

    currentRoom={
      name:roomData.name || '',
      spawn,
      obstacles:currentObstacles,
      props:currentProps,
      world:currentWorld,
      parallaxLayers:currentParallaxLayers,
      lights:Graphics.lights
    };

    // Move the player to the new spawn and recentre the camera.
    player.x=spawn.x;
    player.y=spawn.y;
    player.frame=1;
    player.tick=0;
    clampPlayerToWorld();
    resetCameraToPlayer();
  }

  function goToRoom(index){
    if(!roomNames.length) return;
    currentRoomIndex=((index%roomNames.length)+roomNames.length)%roomNames.length;
    const roomName=roomNames[currentRoomIndex];
    loadRoom(rooms[roomName]);
    showNotice(`Entered ${roomName}`);
  }

  function goToNextRoom(){
    // Keyboard shortcut uses this to advance to the next room in the list.
    goToRoom(currentRoomIndex+1);
  }
  function getObstacles(){ return currentObstacles; }
  function getProps(){ return currentProps; }
  function getParallaxLayers(){ return currentParallaxLayers.length ? currentParallaxLayers : createDefaultParallaxLayers(); }

  function clampPlayerToWorld(){
    const world=getActiveWorld();
    const halfW=player.collider.w/2;
    const halfH=player.collider.h/2;
    player.x=Math.min(Math.max(player.x, halfW), world.width-halfW);
    player.y=Math.min(Math.max(player.y, halfH), world.height-halfH);
  }

  function resetCameraToPlayer(){
    const world=getActiveWorld();
    camera.x=player.x-camera.width/2;
    camera.y=player.y-camera.height/2;
    clampCameraToWorld(camera, camera.width, camera.height, world);
  }

  // Load the initial room before starting the game loop
  goToRoom(0);

  // ===== Collision helpers =====
  function rectsOverlap(a,b){
    return a.left < b.x + b.w && a.right > b.x && a.top < b.y + b.h && a.bottom > b.y;
  }

  function isRectVisible(rect){
    return rect.x + rect.w > camera.x && rect.x < camera.x + camera.width && rect.y + rect.h > camera.y && rect.y < camera.y + camera.height;
  }

  function clampCameraToWorld(cam, viewW, viewH, world){
    if(!cam) return;
    const activeWorld=world ?? getActiveWorld();
    const camWidth=Number.isFinite(viewW)?viewW:(cam.width ?? 0);
    const camHeight=Number.isFinite(viewH)?viewH:(cam.height ?? 0);
    const maxX=Math.max(0, activeWorld.width-camWidth);
    const maxY=Math.max(0, activeWorld.height-camHeight);
    cam.x=Math.min(Math.max(cam.x,0), maxX);
    cam.y=Math.min(Math.max(cam.y,0), maxY);
  }

  function updateCamera(){
    // Camera follows the player only when they leave a centered deadzone.
    // We measure the player's distance from the deadzone edges and shift the
    // camera just enough to bring them back inside, which prevents jitter.
    const halfDeadW=camera.deadzone.width/2;
    const halfDeadH=camera.deadzone.height/2;
    const deadLeft=camera.x + camera.width/2 - halfDeadW;
    const deadRight=camera.x + camera.width/2 + halfDeadW;
    const deadTop=camera.y + camera.height/2 - halfDeadH;
    const deadBottom=camera.y + camera.height/2 + halfDeadH;

    if(player.x < deadLeft){ camera.x += player.x - deadLeft; }
    else if(player.x > deadRight){ camera.x += player.x - deadRight; }

    if(player.y < deadTop){ camera.y += player.y - deadTop; }
    else if(player.y > deadBottom){ camera.y += player.y - deadBottom; }

    clampCameraToWorld(camera, camera.width, camera.height, getActiveWorld());
  }

  function tryMove(axis, amount, obstacles){
    // Axis-aligned collision resolution: move along one axis, clamp against
    // colliders, then move along the other axis. This produces natural
    // "sliding" when hitting corners because the non-blocked axis still moves.
    if(amount===0) return;
    const halfW=player.collider.w/2;
    const halfH=player.collider.h/2;
    if(axis==='x'){
      let newX=player.x+amount;
      const rect={ left:newX-halfW, right:newX+halfW, top:player.y-halfH, bottom:player.y+halfH };
      for(const ob of obstacles){
        if(!rectsOverlap(rect,{ x:ob.x, y:ob.y, w:ob.w, h:ob.h })) continue;
        if(amount>0){ newX=ob.x-halfW; rect.left=newX-halfW; rect.right=newX+halfW; }
        else { newX=ob.x+ob.w+halfW; rect.left=newX-halfW; rect.right=newX+halfW; }
      }
      player.x=newX;
    } else if(axis==='y'){
      let newY=player.y+amount;
      const rect={ left:player.x-halfW, right:player.x+halfW, top:newY-halfH, bottom:newY+halfH };
      for(const ob of obstacles){
        if(!rectsOverlap(rect,{ x:ob.x, y:ob.y, w:ob.w, h:ob.h })) continue;
        if(amount>0){ newY=ob.y-halfH; rect.top=newY-halfH; rect.bottom=newY+halfH; }
        else { newY=ob.y+ob.h+halfH; rect.top=newY-halfH; rect.bottom=newY+halfH; }
      }
      player.y=newY;
    }
  }

  function update(dt){
    const obstacles=getObstacles();
    let dx=0,dy=0;
    if(pressed.has('ArrowUp')||pressed.has('w')){ dy-=1; player.dir='up'; }
    if(pressed.has('ArrowDown')||pressed.has('s')){ dy+=1; player.dir='down'; }
    if(pressed.has('ArrowLeft')||pressed.has('a')){ dx-=1; player.dir='left'; }
    if(pressed.has('ArrowRight')||pressed.has('d')){ dx+=1; player.dir='right'; }

    const len=Math.hypot(dx,dy);
    if(len>0){ dx/=len; dy/=len; }

    const moveX=dx*player.speed*dt;
    const moveY=dy*player.speed*dt;
    const isMoving=Math.abs(moveX)>0.001 || Math.abs(moveY)>0.001;
    player.state=isMoving?'run':'idle';
    if(isMoving && !player.wasMoving){
      spawnDustBurst(4,dx,dy);
    } else if(!isMoving && player.wasMoving){
      spawnDustBurst(3,0,0);
    }
    player.wasMoving=isMoving;

    tryMove('x',moveX,obstacles);
    clampPlayerToWorld();
    tryMove('y',moveY,obstacles);
    clampPlayerToWorld();

    if(isMoving){
      player.tick+=dt;
      if(player.tick>0.18){ player.frame=(player.frame+1)%SHEET_COLS; player.tick=0; }
    } else {
      player.frame=1;
      player.tick=0;
    }

    updateCamera();
    updateParticles(dt);
  }

  function drawParallaxLayers(){
    const g=Graphics.sceneCtx;
    const layers=getParallaxLayers();

    g.clearRect(0,0,camera.width,camera.height);

    const sky=g.createLinearGradient(0,0,0,camera.height);
    sky.addColorStop(0,'#0b1326');
    sky.addColorStop(1,'#0b1020');
    g.fillStyle=sky;
    g.fillRect(0,0,camera.width,camera.height);

    for(const layer of layers){
      const factor=layer.factor ?? 0.5;
      const offsetX=(camera.x*factor)% (layer.spacing||camera.width);
      const offsetY=(camera.y*factor)% (layer.spacing||camera.height);
      if(layer.type==='gradient'){
        const grad=g.createLinearGradient(0,0,0,camera.height);
        grad.addColorStop(0,layer.colors?.[0]||'#0b1326');
        grad.addColorStop(1,layer.colors?.[1]||'#111827');
        g.fillStyle=grad;
        g.fillRect(0,0,camera.width,camera.height);
        continue;
      }
      if(layer.type==='hills'){
        const spacing=layer.spacing||320;
        const amplitude=layer.amplitude||60;
        const base=layer.base||300;
        const startX=-spacing*2 - offsetX;
        const endX=camera.width+spacing*2;
        g.fillStyle=layer.color||'#1e293b';
        for(let x=startX; x<endX; x+=spacing){
          const peakX=x+spacing/2;
          g.beginPath();
          g.moveTo(x, camera.height - base + offsetY);
          g.quadraticCurveTo(peakX, camera.height - (base+amplitude) + offsetY, x+spacing, camera.height - base + offsetY);
          g.lineTo(x+spacing, camera.height+20);
          g.lineTo(x, camera.height+20);
          g.closePath();
          g.fill();
        }
        continue;
      }
      if(layer.type==='foreground'){
        g.fillStyle=layer.color||'#1f3b5f';
        g.fillRect(-offsetX, camera.height-(layer.height||140)+offsetY, camera.width+(layer.spacing||camera.width)*2, (layer.height||140)+40);
        continue;
      }
    }
  }

  const OBSTACLE_COLORS={
    rock:'#475569',
    tree:'#334155',
    wall:'#64748b',
    default:'#4b5563'
  };

  function drawObstacle(ob){
    const g=Graphics.sceneCtx;
    const screenX=snapPixel(ob.x-camera.x);
    const screenY=snapPixel(ob.y-camera.y);
    g.fillStyle=OBSTACLE_COLORS[ob.type] || OBSTACLE_COLORS.default;
    g.fillRect(screenX,screenY,ob.w,ob.h);
    g.strokeStyle='rgba(8,12,20,0.65)';
    g.lineWidth=1;
    g.strokeRect(screenX+0.5,screenY+0.5,ob.w-1,ob.h-1);
  }

  function drawTorchProp(prop,x,y,outlineColor,outlineThickness){
    const g=Graphics.sceneCtx;
    const width=Math.max(6,prop.w||16);
    const height=Math.max(24,prop.h||48);
    const flameHeight=Math.max(10,height*0.4);
    const stemHeight=Math.max(8,height-flameHeight);
    const stemWidth=Math.max(4,Math.min(width*0.4,width-4));
    const baseHeight=Math.min(stemHeight,Math.max(4,stemHeight*0.25));
    const baseWidth=Math.min(width,Math.max(stemWidth*1.4,width*0.75));
    const baseX=x+(width-baseWidth)/2;
    const baseY=y+flameHeight+stemHeight-baseHeight;
    const stemX=x+(width-stemWidth)/2;
    const stemY=y+flameHeight;
    const handleColor=prop.handleColor||'#5b341b';
    const sconceColor=prop.sconceColor||'#475569';

    drawOutlinedRect(g,baseX,baseY,baseWidth,baseHeight,sconceColor,outlineColor,outlineThickness);
    drawOutlinedRect(g,stemX,stemY,stemWidth,stemHeight,handleColor,outlineColor,outlineThickness);

    const flameWidth=Math.min(width,Math.max(stemWidth*1.6,width*0.85));
    const flameX=x+(width-flameWidth)/2;
    const flameY=y+Math.max(0,flameHeight*0.05);
    const flameTopColor=prop.flameHighlight||'#fde68a';
    const flameBottomColor=prop.flameColor||'#f97316';

    g.save();
    const gradient=g.createLinearGradient(flameX,flameY,flameX,flameY+flameHeight);
    gradient.addColorStop(0,flameTopColor);
    gradient.addColorStop(1,flameBottomColor);
    g.fillStyle=gradient;
    g.beginPath();
    g.moveTo(flameX+flameWidth/2,flameY);
    g.bezierCurveTo(flameX,flameY+flameHeight*0.55,flameX+flameWidth*0.2,flameY+flameHeight,flameX+flameWidth/2,flameY+flameHeight);
    g.bezierCurveTo(flameX+flameWidth*0.8,flameY+flameHeight,flameX+flameWidth,flameY+flameHeight*0.55,flameX+flameWidth/2,flameY);
    g.closePath();
    g.fill();
    g.restore();

    g.save();
    g.fillStyle='rgba(255,255,255,0.45)';
    g.beginPath();
    g.ellipse(flameX+flameWidth/2,flameY+flameHeight*0.3,flameWidth*0.22,flameHeight*0.35,0,0,Math.PI*2);
    g.fill();
    g.restore();

    g.save();
    g.globalCompositeOperation='lighter';
    g.fillStyle=prop.glowColor||'rgba(251,191,36,0.4)';
    g.beginPath();
    g.ellipse(flameX+flameWidth/2,flameY+flameHeight*0.45,flameWidth*0.9,flameHeight*1.05,0,0,Math.PI*2);
    g.fill();
    g.restore();
  }

  function drawProp(prop){
    const g=Graphics.sceneCtx;
    const x=snapPixel(prop.x-camera.x);
    const y=snapPixel(prop.y-camera.y);
    const outlineColor=prop.outlineColor ?? Graphics.outlineColor;
    const outlineThickness=prop.outlineThickness ?? Graphics.outlineThickness;

    if(prop.type==='torch'){
      drawTorchProp(prop,x,y,outlineColor,outlineThickness);
      return;
    }

    if((prop.shadow ?? prop.height>0)){
      const baseX=x+prop.w/2;
      const baseY=y+prop.h;
      const radiusX=Math.max(6,prop.w*0.45);
      const radiusY=Math.max(3,(prop.height||prop.h*0.25)*0.25);
      g.save();
      g.fillStyle='rgba(10,12,20,0.4)';
      g.beginPath();
      g.ellipse(baseX,baseY,radiusX,radiusY,0,0,Math.PI*2);
      g.fill();
      g.restore();
    }
    const spriteEntry=prop.sprite;
    if(spriteEntry && spriteEntry.ready){
      drawOutlinedSprite(g,spriteEntry.img,0,0,spriteEntry.img.width,spriteEntry.img.height,x,y,prop.w,prop.h,outlineColor,outlineThickness);
    } else {
      drawOutlinedRect(g,x,y,prop.w,prop.h,prop.color||'#94a3b8',outlineColor,outlineThickness);
      if(spriteEntry && spriteEntry.error){
        g.strokeStyle='#ef4444';
        g.beginPath();
        g.moveTo(x+4,y+4);
        g.lineTo(x+prop.w-4,y+prop.h-4);
        g.moveTo(x+prop.w-4,y+4);
        g.lineTo(x+4,y+prop.h-4);
        g.stroke();
      }
    }
  }

  function drawPlayer(){
    const g=Graphics.sceneCtx;
    const px=player.x-camera.x;
    const py=player.y-camera.y;
    const entry=SPRITES[activeSpriteName];
    if(spriteReady && entry && entry.image){
      const {sx,sy,sw,sh}=frameRect(player.dir,player.frame);
      const destX=px-sw/2;
      const destY=py-sh/2;
      drawOutlinedSprite(g,entry.image,sx,sy,sw,sh,destX,destY,sw,sh,player.outlineColor||Graphics.outlineColor,player.outlineThickness||Graphics.outlineThickness);
    } else {
      const fallbackW=Math.max(20,frameW||32);
      const fallbackH=Math.max(20,frameH||32);
      const color=entry?.placeholderColor || '#e5e7eb';
      drawOutlinedRect(
        g,
        px-fallbackW/2,
        py-fallbackH/2,
        fallbackW,
        fallbackH,
        color,
        player.outlineColor||Graphics.outlineColor,
        player.outlineThickness||Graphics.outlineThickness
      );
    }
  }

  // ===== Particle effects (dust puffs on acceleration/braking) =====
  function spawnDustBurst(count=3,dirX=0,dirY=0){
    const originX=player.x;
    const originY=player.y + (player.collider?.h||24)*0.35;
    for(let i=0;i<count;i++){
      const angle=Math.random()*Math.PI*2;
      const speed=30+Math.random()*50;
      const vx=Math.cos(angle)*speed + dirX*30;
      const vy=Math.sin(angle)*speed + dirY*30;
      particles.push({
        x:originX+(Math.random()-0.5)*6,
        y:originY+(Math.random()-0.5)*4,
        vx,
        vy,
        life:0,
        maxLife:0.35+Math.random()*0.2,
        size:2.2+Math.random()*1.6
      });
    }
  }

  function updateParticles(dt){
    for(let i=particles.length-1;i>=0;i--){
      const p=particles[i];
      p.life+=dt;
      if(p.life>=p.maxLife){
        particles.splice(i,1);
        continue;
      }
      p.x+=p.vx*dt;
      p.y+=p.vy*dt;
      p.vx*=0.85;
      p.vy*=0.85;
    }
  }

  function drawParticles(){
    if(!particles.length) return;
    const g=Graphics.sceneCtx;
    g.save();
    g.globalCompositeOperation='lighter';
    for(const p of particles){
      const progress=p.life/p.maxLife;
      const alpha=Math.max(0,0.55-progress*0.55);
      if(alpha<=0) continue;
      const screenX=p.x-camera.x;
      const screenY=p.y-camera.y;
      if(screenX<-20 || screenX>camera.width+20 || screenY<-20 || screenY>camera.height+20) continue;
      const size=p.size*(1+progress*0.4);
      g.fillStyle=`rgba(205,214,230,${alpha})`;
      g.beginPath();
      g.ellipse(screenX,screenY,size,size*0.6,0,0,Math.PI*2);
      g.fill();
    }
    g.restore();
  }

  function drawWorld(){
    const drawList=[];
    for(const ob of getObstacles()){
      if(!isRectVisible(ob)) continue;
      drawList.push({ type:'obstacle', y:ob.y+ob.h, data:ob });
    }
    for(const prop of getProps()){
      if(!isRectVisible(prop)) continue;
      drawList.push({ type:'prop', y:prop.y+prop.h, data:prop });
    }
    drawList.sort((a,b)=>a.y-b.y);
    for(const item of drawList){
      if(item.type==='obstacle') drawObstacle(item.data);
      else drawProp(item.data);
    }
    drawPlayer();
  }

  // ===== Toon lighting pass =====
  function celLighting(){
    const g=Graphics.sceneCtx;
    const lctx=Graphics.lightingCtx;
    const width=camera.width;
    const height=camera.height;
    const ambient=Math.max(0,Math.min(1,Graphics.ambientDarkness));
    const ambientBrightness=1-ambient;
    const baseChannel=Math.round(ambientBrightness*255);
    const toneSource=(Array.isArray(Graphics.toneLevels) && Graphics.toneLevels.length)
      ? Graphics.toneLevels
      : DEFAULT_TONE_LEVELS;
    const toneLevels=toneSource.slice().sort((a,b)=>a-b);
    const bandCount=toneLevels.length||1;

    lctx.save();
    lctx.globalCompositeOperation='source-over';
    lctx.clearRect(0,0,width,height);
    lctx.fillStyle=`rgb(${baseChannel},${baseChannel},${baseChannel})`;
    lctx.fillRect(0,0,width,height);

    const activeLights=[];
    if(Array.isArray(Graphics.lights)) activeLights.push(...Graphics.lights);
    if(Graphics.playerLightEnabled){
      activeLights.push({
        x:player.x,
        y:player.y+(player.collider?.h||0)*0.35,
        radius:Graphics.playerLightRadius,
        intensity:Graphics.playerLightIntensity
      });
    }

    for(const light of activeLights){
      const radius=Math.max(4,Number(light.radius)||0);
      const intensity=Math.max(0,Math.min(1,Number(light.intensity ?? 1)));
      if(intensity<=0 || radius<=0) continue;
      const cx=light.x-camera.x;
      const cy=light.y-camera.y;
      if(cx+radius< -100 || cy+radius< -100 || cx-radius>width+100 || cy-radius>height+100) continue;
      const centerX=snapPixel(cx);
      const centerY=snapPixel(cy);
      for(let i=0;i<toneLevels.length;i++){
        const level=Math.max(0,Math.min(1,toneLevels[i]));
        const ratio=(bandCount-i)/bandCount;
        let bandRadius=radius*ratio;
        if(Graphics.pixelArtMode) bandRadius=Math.max(1,Math.round(bandRadius));
        if(bandRadius<=0) continue;
        const brightness=ambientBrightness + (1-ambientBrightness)*level*intensity;
        const channel=Math.round(Math.max(ambientBrightness,Math.min(1,brightness))*255);
        lctx.beginPath();
        lctx.arc(centerX,centerY,bandRadius,0,Math.PI*2);
        lctx.closePath();
        lctx.fillStyle=`rgb(${channel},${channel},${channel})`;
        lctx.fill();
      }
    }
    lctx.restore();

    g.save();
    g.globalCompositeOperation='multiply';
    g.drawImage(Graphics.lightingCanvas,0,0,width,height);
    g.restore();
    g.globalCompositeOperation='source-over';
  }

  function draw(){
    drawParallaxLayers();
    drawWorld();
    drawParticles();
    celLighting();

    ctx.save();
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,gameC.width,gameC.height);
    ctx.drawImage(Graphics.sceneCanvas,0,0,Graphics.sceneCanvas.width,Graphics.sceneCanvas.height,0,0,gameC.width,gameC.height);
    ctx.restore();
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }

  let last=0;
  function loop(now){
    const dt=Math.min(0.033,(now-last)/1000);
    last=now;
    update(dt);
    draw();
    requestAnimationFrame(loop);
  }

  async function startGameLoop(){
    await initialSpritePromise;
    updatePlayerCollider();
    last=performance.now();
    requestAnimationFrame(loop);
  }
  startGameLoop();

  // ===== Tests (keep existing and add a few more) =====
  const results=[]; function assert(name,cond){ results.push({name,pass:!!cond}); if(!cond) console.error('[TEST FAIL]',name); }
  function runTests(){
    assert('frame cell width > 0', frameW>0);
    assert('frame cell height > 0', frameH>0);
    const r0=frameRect('down',0); assert('frameRect sx >= 0', r0.sx>=0);
    const r1=frameRect('up',2); assert('frameRect sy for up row correct', r1.sy===frameH*3);
    const activeEntry=SPRITES[activeSpriteName];
    if(spriteReady && activeEntry && activeEntry.image){
      const width=activeEntry.image.naturalWidth || activeEntry.image.width || 0;
      const height=activeEntry.image.naturalHeight || activeEntry.image.height || 0;
      assert('sprite width > 0', width>0);
      assert('sprite height > 0', height>0);
      if(!activeEntry.placeholder){
        assert('3 columns detected', Math.round(width / frameW) === SHEET_COLS);
        assert('4 rows detected', Math.round(height / frameH) === SHEET_ROWS);
      }
    }
    const rL = frameRect('left',2); assert('left row index', rL.sy===frameH*1);
    const rR = frameRect('right',2); assert('right row index', rR.sy===frameH*2);
    const roomAfterLoad=currentRoom;
    assert('room loaded', !!roomAfterLoad);
    assert('spawn applied to player', Math.round(player.x)===Math.round(roomAfterLoad.spawn.x));
    console.log(results);
  }
  setTimeout(runTests,2200);
  </script>
</body>
</html>
