<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Canvas RPG — Robust Sprite Loading (3×4 locked)</title>
  <style>
    html,body{margin:0;height:100%;background:#0a0f1f;color:#e5e7eb;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;overflow:hidden}
    #root{height:100%;position:relative}
    canvas{position:absolute;inset:0;display:block}
    .notice{position:fixed;top:10px;left:50%;transform:translateX(-50%);background:#111827cc;border:1px solid #243b55;border-radius:10px;padding:8px 12px;font:12px/1.4 ui-monospace,monospace;z-index:9999}
    .toolbar{position:fixed;right:10px;bottom:10px;background:#111827cc;border:1px solid #243b55;border-radius:10px;padding:8px 12px;font:12px/1.4 ui-monospace,monospace;z-index:9999;display:flex;gap:8px;align-items:center}
    .toolbar input[type="text"]{width:260px}
    .drop{position:fixed;inset:0;border:2px dashed #47556955;border-radius:12px;display:none;place-items:center;background:#0a0f1faa;color:#cbd5e1;font:14px/1.4 ui-monospace,monospace;z-index:9998}
    .drop.show{display:grid}
  </style>
</head>
<body>
  <div id="root">
    <canvas id="bg"></canvas>
    <canvas id="game" tabindex="0"></canvas>
  </div>

  <div id="notice" class="notice" style="display:none"></div>

  <div class="toolbar" style="opacity:0.95">
    <label>Sprite URL: <input id="spriteUrl" type="text" placeholder="Male 02.2.png or https://..." /></label>
    <button id="btnLoad">Load</button>
    <input id="fileInput" type="file" accept="image/png,image/jpeg" style="display:none" />
    <button id="btnFile">Choose File…</button>
    <select id="spriteSelect" style="margin-left:8px">
      <option value="assets/Male 02-2.png">Male 02-2</option>
      <option value="assets/Male 02-2.png">Male 17-3</option>
      <option value="assets/Male 18-1.png">Male 18-1</option>
    </select>
  </div>
  <div id="drop" class="drop">Drop a PNG/JPG sprite sheet here (3 frames × 4 rows)</div>

  <script>
  // ===== Canvas setup =====
  const dpr = Math.min(devicePixelRatio||1,2);
  const bgC = document.getElementById('bg');
  const gameC = document.getElementById('game');
  const bg = bgC.getContext('2d');
  const ctx = gameC.getContext('2d');
  let currentRoom=null;          // currently active room definition
  const currentObstacles=[];     // obstacles for collision/rendering
  const currentProps=[];         // decorative props for the current room
  let currentParallaxLayers=[];  // parallax layers per room (defaults later)
  let camera=null;
  ctx.imageSmoothingEnabled=false;
  bg.imageSmoothingEnabled=false;
  function resize(){
    bgC.width=innerWidth*dpr;
    bgC.height=innerHeight*dpr;
    bg.setTransform(dpr,0,0,dpr,0,0);
    gameC.width=innerWidth*dpr;
    gameC.height=innerHeight*dpr;
    ctx.setTransform(dpr,0,0,dpr,0,0);
    if(camera){
      resizeCamera();
      clampCameraToWorld();
    }
  }
  addEventListener('resize',resize);
  function drawBackground(){ const g=bg.createLinearGradient(0,0,0,innerHeight); g.addColorStop(0,'#1a2b45'); g.addColorStop(1,'#0b1326'); bg.fillStyle=g; bg.fillRect(0,0,innerWidth,innerHeight); }

  // ===== UI notice helper =====
  const noticeEl = document.getElementById('notice');
  function showNotice(msg){ noticeEl.textContent=msg; noticeEl.style.display='block'; clearTimeout(showNotice._t); showNotice._t=setTimeout(()=>noticeEl.style.display='none',7000); }
  function getParam(name){ const u=new URL(location.href); return u.searchParams.get(name); }

  // ===== Sprite loading (robust) =====
  // Layout is permanently locked: 4 rows (down,left,right,up) × 3 columns (frames)
  const SHEET_COLS = 3, SHEET_ROWS = 4;
  const DIR_ROW={ down:0, left:1, right:2, up:3 };

  let sprite=null;          // HTMLImageElement
  let spriteReady=false;    // ready flag
  let frameW=32, frameH=32; // computed on load
  let currentObjectUrl=null;// revoke blob URLs when replaced

  const spriteReadyResolvers=[];
  function resolveSpriteWaiters(){
    while(spriteReadyResolvers.length){
      const resolve=spriteReadyResolvers.shift();
      try{ resolve(sprite); }
      catch(err){ console.error('Sprite ready callback failed', err); }
    }
  }
  function waitForSpriteReady(){
    if(spriteReady) return Promise.resolve(sprite);
    return new Promise(resolve=>spriteReadyResolvers.push(resolve));
  }

  const DEFAULT_SOURCES = [
    ...(localStorage.getItem("spriteURL") ? [localStorage.getItem("spriteURL")] : []),
    "assets/Male 02-2.png",
    "assets/Male 02-2.png",
    "Male 02-2.png",
    "Male 02.2.png",
    "./Male 02-2.png",
    "./Male 02-2.png",
    "Male%2002-2.png",
    "Male%2017-3.png"
  ];

  function generateFallbackSprite(size=32){
    // 3×4 sheet with simple placeholder character
    const cols=3, rows=4, w=size*cols, h=size*rows;
    const c=document.createElement('canvas'); c.width=w; c.height=h; const g=c.getContext('2d');
    const cloaks=['#60a5fa','#34d399','#f59e0b','#ef4444'];
    for(let r=0;r<rows;r++){
      for(let f=0; f<cols; f++){
        const x=f*size, y=r*size;
        g.fillStyle = r%2? '#0f172a' : '#111827'; g.fillRect(x,y,size,size);
        g.fillStyle = cloaks[r]; g.fillRect(x+8,y+10,size-16,size-14);
        g.fillStyle = '#e5e7eb'; g.beginPath(); g.arc(x+size/2, y+8, 6, 0, Math.PI*2); g.fill();
        g.fillStyle = '#0b0f19'; g.fillRect(x+8+(f%2?4:0), y+size-8, 6, 4); g.fillRect(x+size-14-(f%2?4:0), y+size-8, 6, 4);
      }
    }
    return c.toDataURL('image/png');
  }

  function useFallback(){
    spriteReady=false; const url=generateFallbackSprite(32); const img=new Image();
    img.onload=()=>{ sprite=img; spriteReady=true; frameW=Math.floor(img.naturalWidth/SHEET_COLS); frameH=Math.floor(img.naturalHeight/SHEET_ROWS); showNotice('Using fallback sprite. Place \"Male 02-2.png\" next to this file, paste a URL, or drop a file.'); resolveSpriteWaiters(); };
    img.onerror=()=>{ spriteReady=false; showNotice('Fallback sprite failed to load (unexpected).'); };
    img.src=url;
  }

  function loadSprite(url){
    if(currentObjectUrl && url!==currentObjectUrl){ URL.revokeObjectURL(currentObjectUrl); currentObjectUrl=null; }
    spriteReady=false; const img=new Image(); img.decoding='async'; img.loading='eager'; img.crossOrigin='anonymous';
    img.onload=()=>{
      if(img.naturalWidth>0 && img.naturalHeight>0){
        sprite=img; spriteReady=true;
        frameW=Math.floor(img.naturalWidth/SHEET_COLS);
        frameH=Math.floor(img.naturalHeight/SHEET_ROWS);
        showNotice('Loaded sprite: '+url);
        resolveSpriteWaiters();
      } else { showNotice('Sprite loaded but has no size — using fallback.'); useFallback(); }
    };
    img.onerror=()=>{ showNotice('Failed to load sprite at: '+url); tryNextSource(); };
    img.src=url;
  }

  // Try a list of sources in order, then fallback
  let _tryList=[]; let _tryIndex=0;
  function trySources(list){ _tryList=list.slice(); _tryIndex=0; tryNextSource(); }
  function tryNextSource(){ if(_tryIndex<_tryList.length){ const nxt=_tryList[_tryIndex++]; loadSprite(nxt); } else { useFallback(); } }

  const qp = getParam("sprite");
  const saved = localStorage.getItem("spriteURL");

  const initialSpritePromise=waitForSpriteReady();

  if(qp){
    trySources([qp]);
  } else if(saved){
    trySources([saved]);
  } else {
    trySources(DEFAULT_SOURCES);
  }

  const urlInput=document.getElementById('spriteUrl');
  urlInput.value = qp || saved || DEFAULT_SOURCES[0] || "";

  document.getElementById("btnLoad").onclick = () => {
    const v = document.getElementById("spriteUrl").value.trim();
    if (v) {
      localStorage.setItem("spriteURL", v);
      trySources([v]);
    }
  };

  const spriteSelect = document.getElementById("spriteSelect");
  if (spriteSelect) {
    const current = localStorage.getItem("spriteURL") || urlInput.value;
    if (current) {
      for (const opt of spriteSelect.options) {
        if (opt.value === current) spriteSelect.value = current;
      }
    }
    spriteSelect.addEventListener("change", () => {
      const url = spriteSelect.value;
      localStorage.setItem("spriteURL", url);
      urlInput.value = url;
      trySources([url]);
    });
  }

  const fileInput=document.getElementById('fileInput');
  document.getElementById('btnFile').onclick=()=>fileInput.click();
  fileInput.onchange = () => {
    const f = fileInput.files && fileInput.files[0];
    if (!f) return;
    const url = URL.createObjectURL(f);
    currentObjectUrl = url;
    localStorage.setItem("spriteURL", url);
    trySources([url]);
  };

  const drop=document.getElementById('drop');
  ['dragenter','dragover'].forEach(ev=>addEventListener(ev,e=>{e.preventDefault(); drop.classList.add('show');}));
  ['dragleave','drop'].forEach(ev => addEventListener(ev, e => {
    e.preventDefault();
    if (ev === 'drop') {
      const f = e.dataTransfer.files && e.dataTransfer.files[0];
      if (f) {
        const url = URL.createObjectURL(f);
        currentObjectUrl = url;
        localStorage.setItem("spriteURL", url);
        trySources([url]);
      }
    }
    drop.classList.remove('show');
  }));

  // ===== Player, input, animation (3×4 locked) =====
  const player={
    x:200,
    y:200,
    speed:200,
    frame:1,
    dir:'down',
    tick:0,
    collider:{ w:24, h:28 }
  };
  const pressed=new Set();
  function normKey(k){ const map={Left:'ArrowLeft',Right:'ArrowRight',Up:'ArrowUp',Down:'ArrowDown'}; return map[k] || (k.length===1?k.toLowerCase():k); }
  // Global keybinds: WASD/arrow for movement, 'N' jumps to the next room.
  addEventListener('keydown',e=>{
    const k=normKey(e.key);
    if(k==='n'){
      if(!e.repeat){
        e.preventDefault();
        goToNextRoom();
      }
      return;
    }
    if(k.startsWith('Arrow')) e.preventDefault();
    pressed.add(k);
  });
  addEventListener('keyup',e=>{ const k=normKey(e.key); if(k.startsWith('Arrow')) e.preventDefault(); pressed.delete(k); });

  function frameRect(dir,frame){
    const row={down:0,left:1,right:2,up:3}[dir];
    const col=Math.max(0,Math.min(SHEET_COLS-1, frame));
    return { sx:col*frameW, sy:row*frameH, sw:frameW, sh:frameH };
  }

  function updatePlayerCollider(){
    // Shrink the collision box so the player feels responsive.
    player.collider.w=Math.max(18,Math.min(frameW*0.6, frameW));
    player.collider.h=Math.max(20,Math.min(frameH*0.7, frameH));
  }
  waitForSpriteReady().then(updatePlayerCollider);

  // ===== Camera setup =====
  camera={
    x:0,
    y:0,
    width:innerWidth,
    height:innerHeight,
    deadzone:{ width:360, height:220 }
  };

  function resizeCamera(){
    if(!camera) return;
    camera.width=innerWidth;
    camera.height=innerHeight;
  }
  resize();

  // ===== World data & loading =====
  const propSpriteCache=new Map();
  function requestPropSprite(url){
    if(!propSpriteCache.has(url)){
      const img=new Image();
      const entry={ img, ready:false, error:false };
      img.onload=()=>{ entry.ready=true; };
      img.onerror=()=>{ entry.error=true; };
      img.src=url;
      propSpriteCache.set(url,entry);
    }
    return propSpriteCache.get(url);
  }

  function createDefaultParallaxLayers(){
    return [
      { factor:0.1, type:'gradient', colors:['#0b1326','#0f172a'] },
      { factor:0.3, type:'hills', color:'#10203a', base:260, amplitude:90, spacing:420 },
      { factor:0.55, type:'hills', color:'#1a2f4f', base:320, amplitude:60, spacing:260 },
      { factor:0.85, type:'foreground', color:'#1f3b5f', height:160 }
    ];
  }

  const DEFAULT_WORLD={ width:1600, height:1200 };

  function cloneObstacles(list){
    return (list||[]).map(o=>({
      x:Number(o.x)||0,
      y:Number(o.y)||0,
      w:Number(o.w)||0,
      h:Number(o.h)||0,
      type:o.type||'wall'
    }));
  }

  function cloneProps(list){
    return (list||[]).map(p=>({
      x:Number(p.x)||0,
      y:Number(p.y)||0,
      w:Number(p.w)||32,
      h:Number(p.h)||32,
      color:p.color||'#94a3b8',
      spriteURL:p.spriteURL||null,
      sprite:null
    }));
  }

  // ----- Room definitions (edit/add rooms here) -----
  const rooms={
    room1:{
      spawn:{ x:320, y:360 },
      obstacles:[
        { x:180, y:200, w:420, h:48, type:'wall' },
        { x:680, y:420, w:96, h:180, type:'tree' },
        { x:520, y:620, w:260, h:56, type:'rock' }
      ],
      props:[
        { x:520, y:260, w:48, h:48, spriteURL:'assets/Male 18-1.png' },
        { x:860, y:480, w:40, h:40 }
      ]
    },
    room2:{
      spawn:{ x:720, y:420 },
      obstacles:[
        { x:260, y:340, w:520, h:60, type:'wall' },
        { x:940, y:360, w:140, h:220, type:'tree' },
        { x:540, y:740, w:360, h:70, type:'rock' }
      ],
      props:[
        { x:600, y:520, w:60, h:60 },
        { x:1040, y:360, w:96, h:96, spriteURL:'assets/Male 18-1.png' }
      ]
    }
  };

  const roomNames=Object.keys(rooms);
  let currentRoomIndex=0;

  // Loader entry point: pass in a plain JS room object (e.g., parsed JSON).
  function loadRoom(roomData){
    if(!roomData) return;

    // Cache spawn so we can position the player before starting the loop.
    const spawn={
      x:Number(roomData.spawn?.x) || 0,
      y:Number(roomData.spawn?.y) || 0
    };

    // Clear old state and copy in the new room geometry.
    currentObstacles.length=0;
    currentProps.length=0;
    currentObstacles.push(...cloneObstacles(roomData.obstacles));

    const props=cloneProps(roomData.props);
    for(const prop of props){
      if(prop.spriteURL){
        prop.sprite=requestPropSprite(prop.spriteURL);
      }
      currentProps.push(prop);
    }

    currentParallaxLayers = roomData.parallaxLayers?.length
      ? roomData.parallaxLayers.map(layer=>({ ...layer }))
      : createDefaultParallaxLayers();

    currentRoom={
      name:roomData.name || '',
      spawn,
      obstacles:currentObstacles,
      props:currentProps,
      world:{
        width:roomData.world?.width ?? DEFAULT_WORLD.width,
        height:roomData.world?.height ?? DEFAULT_WORLD.height
      },
      parallaxLayers:currentParallaxLayers
    };

    // Move the player to the new spawn and recentre the camera.
    player.x=spawn.x;
    player.y=spawn.y;
    player.frame=1;
    player.tick=0;
    clampPlayerToWorld();
    resetCameraToPlayer();
  }

  function goToRoom(index){
    if(!roomNames.length) return;
    currentRoomIndex=((index%roomNames.length)+roomNames.length)%roomNames.length;
    const roomName=roomNames[currentRoomIndex];
    loadRoom(rooms[roomName]);
    showNotice(`Entered ${roomName}`);
  }

  function goToNextRoom(){
    // Keyboard shortcut uses this to advance to the next room in the list.
    goToRoom(currentRoomIndex+1);
  }

  function getActiveWorld(){ return currentRoom?.world ?? DEFAULT_WORLD; }
  function getObstacles(){ return currentObstacles; }
  function getProps(){ return currentProps; }
  function getParallaxLayers(){ return currentParallaxLayers.length ? currentParallaxLayers : createDefaultParallaxLayers(); }

  function clampPlayerToWorld(){
    const world=getActiveWorld();
    const halfW=player.collider.w/2;
    const halfH=player.collider.h/2;
    player.x=Math.min(Math.max(player.x, halfW), world.width-halfW);
    player.y=Math.min(Math.max(player.y, halfH), world.height-halfH);
  }

  function resetCameraToPlayer(){
    const world=getActiveWorld();
    camera.x=player.x-camera.width/2;
    camera.y=player.y-camera.height/2;
    clampCameraToWorld();
  }

  // Load the initial room before starting the game loop
  goToRoom(0);

  // ===== Collision helpers =====
  function rectsOverlap(a,b){
    return a.left < b.x + b.w && a.right > b.x && a.top < b.y + b.h && a.bottom > b.y;
  }

  function isRectVisible(rect){
    return rect.x + rect.w > camera.x && rect.x < camera.x + camera.width && rect.y + rect.h > camera.y && rect.y < camera.y + camera.height;
  }

  function clampCameraToWorld(){
    const world=getActiveWorld();
    const maxX=Math.max(0, world.width-camera.width);
    const maxY=Math.max(0, world.height-camera.height);
    camera.x=Math.min(Math.max(camera.x,0), maxX);
    camera.y=Math.min(Math.max(camera.y,0), maxY);
  }

  function updateCamera(){
    // Camera follows the player only when they leave a centered deadzone.
    // We measure the player's distance from the deadzone edges and shift the
    // camera just enough to bring them back inside, which prevents jitter.
    const halfDeadW=camera.deadzone.width/2;
    const halfDeadH=camera.deadzone.height/2;
    const deadLeft=camera.x + camera.width/2 - halfDeadW;
    const deadRight=camera.x + camera.width/2 + halfDeadW;
    const deadTop=camera.y + camera.height/2 - halfDeadH;
    const deadBottom=camera.y + camera.height/2 + halfDeadH;

    if(player.x < deadLeft){ camera.x += player.x - deadLeft; }
    else if(player.x > deadRight){ camera.x += player.x - deadRight; }

    if(player.y < deadTop){ camera.y += player.y - deadTop; }
    else if(player.y > deadBottom){ camera.y += player.y - deadBottom; }

    clampCameraToWorld();
  }

  function tryMove(axis, amount, obstacles){
    // Axis-aligned collision resolution: move along one axis, clamp against
    // colliders, then move along the other axis. This produces natural
    // "sliding" when hitting corners because the non-blocked axis still moves.
    if(amount===0) return;
    const halfW=player.collider.w/2;
    const halfH=player.collider.h/2;
    if(axis==='x'){
      let newX=player.x+amount;
      const rect={ left:newX-halfW, right:newX+halfW, top:player.y-halfH, bottom:player.y+halfH };
      for(const ob of obstacles){
        if(!rectsOverlap(rect,{ x:ob.x, y:ob.y, w:ob.w, h:ob.h })) continue;
        if(amount>0){ newX=ob.x-halfW; rect.left=newX-halfW; rect.right=newX+halfW; }
        else { newX=ob.x+ob.w+halfW; rect.left=newX-halfW; rect.right=newX+halfW; }
      }
      player.x=newX;
    } else if(axis==='y'){
      let newY=player.y+amount;
      const rect={ left:player.x-halfW, right:player.x+halfW, top:newY-halfH, bottom:newY+halfH };
      for(const ob of obstacles){
        if(!rectsOverlap(rect,{ x:ob.x, y:ob.y, w:ob.w, h:ob.h })) continue;
        if(amount>0){ newY=ob.y-halfH; rect.top=newY-halfH; rect.bottom=newY+halfH; }
        else { newY=ob.y+ob.h+halfH; rect.top=newY-halfH; rect.bottom=newY+halfH; }
      }
      player.y=newY;
    }
  }

  function update(dt){
    const obstacles=getObstacles();
    let dx=0,dy=0;
    if(pressed.has('ArrowUp')||pressed.has('w')){ dy-=1; player.dir='up'; }
    if(pressed.has('ArrowDown')||pressed.has('s')){ dy+=1; player.dir='down'; }
    if(pressed.has('ArrowLeft')||pressed.has('a')){ dx-=1; player.dir='left'; }
    if(pressed.has('ArrowRight')||pressed.has('d')){ dx+=1; player.dir='right'; }

    const len=Math.hypot(dx,dy);
    if(len>0){ dx/=len; dy/=len; }

    const moveX=dx*player.speed*dt;
    const moveY=dy*player.speed*dt;

    tryMove('x',moveX,obstacles);
    clampPlayerToWorld();
    tryMove('y',moveY,obstacles);
    clampPlayerToWorld();

    if(len>0){
      player.tick+=dt;
      if(player.tick>0.18){ player.frame=(player.frame+1)%SHEET_COLS; player.tick=0; }
    } else {
      player.frame=1;
      player.tick=0;
    }

    updateCamera();
  }

  function drawParallaxLayers(){
    const layers=getParallaxLayers();
    // Always start with a clear so the frame is fresh.
    ctx.clearRect(0,0,camera.width,camera.height);

    // Base fill to avoid gaps when the world is smaller than the view.
    const sky=ctx.createLinearGradient(0,0,0,camera.height);
    sky.addColorStop(0,'#0b1326');
    sky.addColorStop(1,'#0b1020');
    ctx.fillStyle=sky;
    ctx.fillRect(0,0,camera.width,camera.height);

    for(const layer of layers){
      const factor=layer.factor ?? 0.5;
      // Parallax uses the camera offset scaled by a factor. Distant layers move
      // less (small factor), while near layers move more (large factor).
      const offsetX=(camera.x*factor)% (layer.spacing||camera.width);
      const offsetY=(camera.y*factor)% (layer.spacing||camera.height);
      if(layer.type==='gradient'){
        const grad=ctx.createLinearGradient(0,0,0,camera.height);
        grad.addColorStop(0,layer.colors?.[0]||'#0b1326');
        grad.addColorStop(1,layer.colors?.[1]||'#111827');
        ctx.fillStyle=grad;
        ctx.fillRect(0,0,camera.width,camera.height);
        continue;
      }
      if(layer.type==='hills'){
        const spacing=layer.spacing||320;
        const amplitude=layer.amplitude||60;
        const base=layer.base||300;
        const startX=-spacing*2 - offsetX;
        const endX=camera.width+spacing*2;
        ctx.fillStyle=layer.color||'#1e293b';
        for(let x=startX; x<endX; x+=spacing){
          const peakX=x+spacing/2;
          ctx.beginPath();
          ctx.moveTo(x, camera.height - base + offsetY);
          ctx.quadraticCurveTo(peakX, camera.height - (base+amplitude) + offsetY, x+spacing, camera.height - base + offsetY);
          ctx.lineTo(x+spacing, camera.height+20);
          ctx.lineTo(x, camera.height+20);
          ctx.closePath();
          ctx.fill();
        }
        continue;
      }
      if(layer.type==='foreground'){
        ctx.fillStyle=layer.color||'#1f3b5f';
        ctx.fillRect(-offsetX, camera.height-(layer.height||140)+offsetY, camera.width+(layer.spacing||camera.width)*2, (layer.height||140)+40);
        continue;
      }
    }
  }

  const OBSTACLE_COLORS={
    rock:'#475569',
    tree:'#334155',
    wall:'#64748b',
    default:'#4b5563'
  };

  function drawObstacle(ob){
    const screenX=Math.round(ob.x-camera.x);
    const screenY=Math.round(ob.y-camera.y);
    ctx.fillStyle=OBSTACLE_COLORS[ob.type] || OBSTACLE_COLORS.default;
    ctx.fillRect(screenX,screenY,ob.w,ob.h);
    ctx.strokeStyle='#0f172a';
    ctx.lineWidth=1;
    ctx.strokeRect(screenX+0.5,screenY+0.5,ob.w-1,ob.h-1);
  }

  function drawProp(prop){
    const x=Math.round(prop.x-camera.x);
    const y=Math.round(prop.y-camera.y);
    const spriteEntry=prop.sprite;
    if(spriteEntry && spriteEntry.ready){
      ctx.drawImage(spriteEntry.img, x, y, prop.w, prop.h);
    } else {
      ctx.fillStyle=prop.color || '#94a3b8';
      ctx.fillRect(x,y,prop.w,prop.h);
      ctx.strokeStyle='#1f2937';
      ctx.strokeRect(x+0.5,y+0.5,prop.w-1,prop.h-1);
      if(spriteEntry && spriteEntry.error){
        ctx.strokeStyle='#ef4444';
        ctx.beginPath();
        ctx.moveTo(x+4,y+4);
        ctx.lineTo(x+prop.w-4,y+prop.h-4);
        ctx.moveTo(x+prop.w-4,y+4);
        ctx.lineTo(x+4,y+prop.h-4);
        ctx.stroke();
      }
    }
  }

  function drawPlayer(){
    const px=player.x-camera.x;
    const py=player.y-camera.y;
    if(spriteReady){
      const {sx,sy,sw,sh}=frameRect(player.dir,player.frame);
      ctx.drawImage(sprite, sx,sy,sw,sh, Math.round(px-sw/2), Math.round(py-sh/2), sw, sh);
    } else {
      ctx.fillStyle="#e5e7eb";
      ctx.beginPath();
      ctx.arc(Math.round(px),Math.round(py),16,0,Math.PI*2);
      ctx.fill();
    }
  }

  function drawWorld(){
    const drawList=[];
    for(const ob of getObstacles()){
      if(!isRectVisible(ob)) continue;
      drawList.push({ type:'obstacle', y:ob.y+ob.h, data:ob });
    }
    for(const prop of getProps()){
      if(!isRectVisible(prop)) continue;
      drawList.push({ type:'prop', y:prop.y+prop.h, data:prop });
    }
    drawList.sort((a,b)=>a.y-b.y);
    for(const item of drawList){
      if(item.type==='obstacle') drawObstacle(item.data);
      else drawProp(item.data);
    }
    drawPlayer();
  }

  function draw(){
    drawParallaxLayers();
    drawWorld();
  }

  let last=0;
  function loop(now){
    const dt=Math.min(0.033,(now-last)/1000);
    last=now;
    update(dt);
    draw();
    requestAnimationFrame(loop);
  }

  async function startGameLoop(){
    await initialSpritePromise;
    updatePlayerCollider();
    last=performance.now();
    requestAnimationFrame(loop);
  }
  startGameLoop();

  // ===== Tests (keep existing and add a few more) =====
  const results=[]; function assert(name,cond){ results.push({name,pass:!!cond}); if(!cond) console.error('[TEST FAIL]',name); }
  function runTests(){
    assert('frame cell width > 0', frameW>0);
    assert('frame cell height > 0', frameH>0);
    const r0=frameRect('down',0); assert('frameRect sx >= 0', r0.sx>=0);
    const r1=frameRect('up',2); assert('frameRect sy for up row correct', r1.sy===frameH*3);
    if(spriteReady){
      assert('3 columns detected', Math.round(sprite.naturalWidth / frameW) === SHEET_COLS);
      assert('4 rows detected', Math.round(sprite.naturalHeight / frameH) === SHEET_ROWS);
    }
    const rL = frameRect('left',2); assert('left row index', rL.sy===frameH*1);
    const rR = frameRect('right',2); assert('right row index', rR.sy===frameH*2);
    const roomAfterLoad=currentRoom;
    assert('room loaded', !!roomAfterLoad);
    assert('spawn applied to player', Math.round(player.x)===Math.round(roomAfterLoad.spawn.x));
    console.log(results);
  }
  setTimeout(runTests,2200);
  </script>
</body>
</html>
