<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Canvas RPG — Robust Sprite Loading (3×4 locked)</title>
  <style>
    html,body{margin:0;height:100%;background:#0a0f1f;color:#e5e7eb;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;overflow:hidden}
    #root{height:100%;position:relative}
    canvas{position:absolute;inset:0;display:block}
    .notice{position:fixed;top:10px;left:50%;transform:translateX(-50%);background:#111827cc;border:1px solid #243b55;border-radius:10px;padding:8px 12px;font:12px/1.4 ui-monospace,monospace;z-index:9999}
    .toolbar{position:fixed;right:10px;bottom:10px;background:#111827cc;border:1px solid #243b55;border-radius:10px;padding:8px 12px;font:12px/1.4 ui-monospace,monospace;z-index:9999;display:flex;gap:8px;align-items:center}
    .toolbar input[type="text"]{width:260px}
    .drop{position:fixed;inset:0;border:2px dashed #47556955;border-radius:12px;display:none;place-items:center;background:#0a0f1faa;color:#cbd5e1;font:14px/1.4 ui-monospace,monospace;z-index:9998}
    .drop.show{display:grid}
  </style>
</head>
<body>
  <div id="root">
    <canvas id="bg"></canvas>
    <canvas id="game" tabindex="0"></canvas>
  </div>

  <div id="notice" class="notice" style="display:none"></div>

  <div class="toolbar" style="opacity:0.95">
    <label>Sprite URL: <input id="spriteUrl" type="text" placeholder="Male 02.2.png or https://..." /></label>
    <button id="btnLoad">Load</button>
    <input id="fileInput" type="file" accept="image/png,image/jpeg" style="display:none" />
    <button id="btnFile">Choose File…</button>
    <select id="spriteSelect" style="margin-left:8px">
      <option value="assets/Male 02-2.png">Male 02-2</option>
      <option value="assets/Male 02-2.png">Male 17-3</option>
      <option value="assets/Male 18-1.png">Male 18-1</option>
    </select>
  </div>
  <div id="drop" class="drop">Drop a PNG/JPG sprite sheet here (3 frames × 4 rows)</div>

  <script>
  // ===== Canvas setup =====
  const dpr = Math.min(devicePixelRatio||1,2);
  const bgC = document.getElementById('bg');
  const gameC = document.getElementById('game');
  const bg = bgC.getContext('2d');
  const ctx = gameC.getContext('2d');

  // Global graphics configuration used by the toon pipeline.
  const DEFAULT_TONE_LEVELS=[0.0,0.55,1.0];
  const Graphics={
    pixelArtMode:false,
    renderScale:1,
    ambientDarkness:0.35,
    outlineColor:'#111',
    outlineThickness:1,
    toneLevels:[...DEFAULT_TONE_LEVELS],
    lights:[],
    playerLightEnabled:true,
    playerLightRadius:220,
    playerLightIntensity:0.85,
    sceneCanvas:document.createElement('canvas'),
    lightingCanvas:document.createElement('canvas'),
    _outlineBuffer:document.createElement('canvas')
  };
  Graphics.sceneCtx=Graphics.sceneCanvas.getContext('2d');
  Graphics.lightingCtx=Graphics.lightingCanvas.getContext('2d');
  Graphics._outlineCtx=Graphics._outlineBuffer.getContext('2d');

  function applyPixelArtSettings(){
    const smoothing=!Graphics.pixelArtMode;
    [ctx,bg,Graphics.sceneCtx,Graphics.lightingCtx,Graphics._outlineCtx].forEach(g=>{
      if(g) g.imageSmoothingEnabled=smoothing;
    });
  }

  function setLights(list){
    Graphics.lights=Array.isArray(list)?list.map(l=>({
      x:Number(l.x)||0,
      y:Number(l.y)||0,
      radius:Math.max(1,Number(l.radius)||0),
      intensity:Math.max(0,Math.min(1,Number(l.intensity ?? 1)))
    })) : [];
  }
  function setPixelArtMode(flag){
    Graphics.pixelArtMode=!!flag;
    applyPixelArtSettings();
  }
  function setAmbientDarkness(v){
    Graphics.ambientDarkness=Math.max(0,Math.min(1,Number(v)||0));
  }
  function setToneLevels(levels){
    if(!Array.isArray(levels)){
      Graphics.toneLevels=[...DEFAULT_TONE_LEVELS];
      return Graphics.toneLevels;
    }
    const sanitized=levels
      .map(value=>Number(value))
      .filter(value=>Number.isFinite(value))
      .map(value=>Math.max(0,Math.min(1,value)));
    Graphics.toneLevels=sanitized.length?sanitized:[...DEFAULT_TONE_LEVELS];
    return Graphics.toneLevels;
  }

  window.Graphics=Graphics;
  window.setLights=setLights;
  window.setPixelArtMode=setPixelArtMode;
  window.setAmbientDarkness=setAmbientDarkness;
  window.setToneLevels=setToneLevels;

  setToneLevels(Graphics.toneLevels);

  applyPixelArtSettings();

  // ===== Outline helpers =====
  const OUTLINE_OFFSETS_BASE=[[-1,0],[1,0],[0,-1],[0,1],[-1,-1],[1,-1],[-1,1],[1,1]];
  function snapPixel(v){ return Graphics.pixelArtMode?Math.round(v):v; }
  function getEffectiveOutlineThickness(thickness){
    const base=Math.max(0.5,Number(thickness)||0);
    const darknessBoost=Graphics.ambientDarkness>0.5?1:0;
    return base+darknessBoost;
  }

  function ensureOutlineBufferSize(width,height){
    const canvas=Graphics._outlineBuffer;
    const targetW=Math.max(width,1);
    const targetH=Math.max(height,1);
    if(canvas.width<targetW) canvas.width=targetW;
    if(canvas.height<targetH) canvas.height=targetH;
    Graphics._outlineCtx.setTransform(1,0,0,1,0,0);
  }

  function drawOutlinedSprite(targetCtx,image,sx,sy,sw,sh,dx,dy,dw=sw,dh=sh,outlineColor=Graphics.outlineColor,thickness=Graphics.outlineThickness){
    if(!image) return;
    const color=outlineColor ?? Graphics.outlineColor;
    const t=getEffectiveOutlineThickness(thickness);
    const offset=Graphics.pixelArtMode?Math.max(1,Math.round(t)):t;
    const pad=offset+2;
    const offW=Math.ceil(dw+pad*2);
    const offH=Math.ceil(dh+pad*2);
    ensureOutlineBufferSize(offW,offH);
    const octx=Graphics._outlineCtx;
    octx.save();
    octx.clearRect(0,0,offW,offH);
    octx.imageSmoothingEnabled=!Graphics.pixelArtMode;
    octx.drawImage(image,sx,sy,sw,sh,pad,pad,dw,dh);
    octx.globalCompositeOperation='source-in';
    octx.fillStyle=color;
    octx.fillRect(0,0,offW,offH);
    octx.globalCompositeOperation='source-over';
    octx.restore();

    const baseX=snapPixel(dx-pad);
    const baseY=snapPixel(dy-pad);
    for(const [ox,oy] of OUTLINE_OFFSETS_BASE){
      const px=Graphics.pixelArtMode?snapPixel(baseX+ox*offset):baseX+ox*offset;
      const py=Graphics.pixelArtMode?snapPixel(baseY+oy*offset):baseY+oy*offset;
      targetCtx.drawImage(Graphics._outlineBuffer,0,0,offW,offH,px,py,offW,offH);
    }
    targetCtx.drawImage(image,sx,sy,sw,sh,snapPixel(dx),snapPixel(dy),dw,dh);
  }

  function drawOutlinedRect(targetCtx,x,y,w,h,color,outlineColor=Graphics.outlineColor,thickness=Graphics.outlineThickness){
    const t=getEffectiveOutlineThickness(thickness);
    const offset=Graphics.pixelArtMode?Math.max(1,Math.round(t)):t;
    const pad=offset+2;
    const offW=Math.ceil(w+pad*2);
    const offH=Math.ceil(h+pad*2);
    ensureOutlineBufferSize(offW,offH);
    const octx=Graphics._outlineCtx;
    const outline=outlineColor ?? Graphics.outlineColor;
    octx.save();
    octx.clearRect(0,0,offW,offH);
    octx.fillStyle='#fff';
    octx.fillRect(pad,pad,w,h);
    octx.globalCompositeOperation='source-in';
    octx.fillStyle=outline;
    octx.fillRect(0,0,offW,offH);
    octx.globalCompositeOperation='source-over';
    octx.restore();

    const baseX=snapPixel(x-pad);
    const baseY=snapPixel(y-pad);
    for(const [ox,oy] of OUTLINE_OFFSETS_BASE){
      const px=Graphics.pixelArtMode?snapPixel(baseX+ox*offset):baseX+ox*offset;
      const py=Graphics.pixelArtMode?snapPixel(baseY+oy*offset):baseY+oy*offset;
      targetCtx.drawImage(Graphics._outlineBuffer,0,0,offW,offH,px,py,offW,offH);
    }
    targetCtx.fillStyle=color;
    targetCtx.fillRect(snapPixel(x),snapPixel(y),w,h);
  }

  let currentRoom=null;          // currently active room definition
  const currentObstacles=[];     // obstacles for collision/rendering
  const currentProps=[];         // decorative props for the current room
  let currentParallaxLayers=[];  // parallax layers per room (defaults later)
  let camera=null;
  function resize(){
    const scale=Math.max(0.25, Number(Graphics.renderScale)||1);
    const screenW=innerWidth*dpr;
    const screenH=innerHeight*dpr;

    bgC.width=screenW;
    bgC.height=screenH;
    bg.setTransform(dpr,0,0,dpr,0,0);

    gameC.width=screenW;
    gameC.height=screenH;
    ctx.setTransform(dpr,0,0,dpr,0,0);

    const offW=Math.max(1,Math.round(screenW*scale));
    const offH=Math.max(1,Math.round(screenH*scale));
    if(Graphics.sceneCanvas.width!==offW || Graphics.sceneCanvas.height!==offH){
      Graphics.sceneCanvas.width=offW;
      Graphics.sceneCanvas.height=offH;
    }
    if(Graphics.lightingCanvas.width!==offW || Graphics.lightingCanvas.height!==offH){
      Graphics.lightingCanvas.width=offW;
      Graphics.lightingCanvas.height=offH;
    }
    Graphics.sceneCtx.setTransform(dpr*scale,0,0,dpr*scale,0,0);
    Graphics.lightingCtx.setTransform(dpr*scale,0,0,dpr*scale,0,0);

    applyPixelArtSettings();

    drawBackground();

    if(camera){
      resizeCamera();
      clampCameraToWorld();
    }
  }
  addEventListener('resize',resize);
  function drawBackground(){ const g=bg.createLinearGradient(0,0,0,innerHeight); g.addColorStop(0,'#1a2b45'); g.addColorStop(1,'#0b1326'); bg.fillStyle=g; bg.fillRect(0,0,innerWidth,innerHeight); }

  // ===== UI notice helper =====
  const noticeEl = document.getElementById('notice');
  function showNotice(msg){ noticeEl.textContent=msg; noticeEl.style.display='block'; clearTimeout(showNotice._t); showNotice._t=setTimeout(()=>noticeEl.style.display='none',7000); }
  function getParam(name){ const u=new URL(location.href); return u.searchParams.get(name); }

  // ===== Sprite loading (robust) =====
  // Layout is permanently locked: 4 rows (down,left,right,up) × 3 columns (frames)
  const SHEET_COLS = 3, SHEET_ROWS = 4;
  const DIR_ROW={ down:0, left:1, right:2, up:3 };

  let sprite=null;          // HTMLImageElement
  let spriteReady=false;    // ready flag
  let frameW=32, frameH=32; // computed on load
  let currentObjectUrl=null;// revoke blob URLs when replaced

  const spriteReadyResolvers=[];
  function resolveSpriteWaiters(){
    while(spriteReadyResolvers.length){
      const resolve=spriteReadyResolvers.shift();
      try{ resolve(sprite); }
      catch(err){ console.error('Sprite ready callback failed', err); }
    }
  }
  function waitForSpriteReady(){
    if(spriteReady) return Promise.resolve(sprite);
    return new Promise(resolve=>spriteReadyResolvers.push(resolve));
  }

  const DEFAULT_SOURCES = [
    ...(localStorage.getItem("spriteURL") ? [localStorage.getItem("spriteURL")] : []),
    "assets/Male 02-2.png",
    "assets/Male 02-2.png",
    "Male 02-2.png",
    "Male 02.2.png",
    "./Male 02-2.png",
    "./Male 02-2.png",
    "Male%2002-2.png",
    "Male%2017-3.png"
  ];

  function generateFallbackSprite(size=32){
    // 3×4 sheet with simple placeholder character
    const cols=3, rows=4, w=size*cols, h=size*rows;
    const c=document.createElement('canvas'); c.width=w; c.height=h; const g=c.getContext('2d');
    const cloaks=['#60a5fa','#34d399','#f59e0b','#ef4444'];
    for(let r=0;r<rows;r++){
      for(let f=0; f<cols; f++){
        const x=f*size, y=r*size;
        g.fillStyle = r%2? '#0f172a' : '#111827'; g.fillRect(x,y,size,size);
        g.fillStyle = cloaks[r]; g.fillRect(x+8,y+10,size-16,size-14);
        g.fillStyle = '#e5e7eb'; g.beginPath(); g.arc(x+size/2, y+8, 6, 0, Math.PI*2); g.fill();
        g.fillStyle = '#0b0f19'; g.fillRect(x+8+(f%2?4:0), y+size-8, 6, 4); g.fillRect(x+size-14-(f%2?4:0), y+size-8, 6, 4);
      }
    }
    return c.toDataURL('image/png');
  }

  function useFallback(){
    spriteReady=false; const url=generateFallbackSprite(32); const img=new Image();
    img.onload=()=>{ sprite=img; spriteReady=true; frameW=Math.floor(img.naturalWidth/SHEET_COLS); frameH=Math.floor(img.naturalHeight/SHEET_ROWS); showNotice('Using fallback sprite. Place \"Male 02-2.png\" next to this file, paste a URL, or drop a file.'); resolveSpriteWaiters(); };
    img.onerror=()=>{ spriteReady=false; showNotice('Fallback sprite failed to load (unexpected).'); };
    img.src=url;
  }

  function loadSprite(url){
    if(currentObjectUrl && url!==currentObjectUrl){ URL.revokeObjectURL(currentObjectUrl); currentObjectUrl=null; }
    spriteReady=false; const img=new Image(); img.decoding='async'; img.loading='eager'; img.crossOrigin='anonymous';
    img.onload=()=>{
      if(img.naturalWidth>0 && img.naturalHeight>0){
        sprite=img; spriteReady=true;
        frameW=Math.floor(img.naturalWidth/SHEET_COLS);
        frameH=Math.floor(img.naturalHeight/SHEET_ROWS);
        showNotice('Loaded sprite: '+url);
        resolveSpriteWaiters();
      } else { showNotice('Sprite loaded but has no size — using fallback.'); useFallback(); }
    };
    img.onerror=()=>{ showNotice('Failed to load sprite at: '+url); tryNextSource(); };
    img.src=url;
  }

  // Try a list of sources in order, then fallback
  let _tryList=[]; let _tryIndex=0;
  function trySources(list){ _tryList=list.slice(); _tryIndex=0; tryNextSource(); }
  function tryNextSource(){ if(_tryIndex<_tryList.length){ const nxt=_tryList[_tryIndex++]; loadSprite(nxt); } else { useFallback(); } }

  const qp = getParam("sprite");
  const saved = localStorage.getItem("spriteURL");

  const initialSpritePromise=waitForSpriteReady();

  if(qp){
    trySources([qp]);
  } else if(saved){
    trySources([saved]);
  } else {
    trySources(DEFAULT_SOURCES);
  }

  const urlInput=document.getElementById('spriteUrl');
  urlInput.value = qp || saved || DEFAULT_SOURCES[0] || "";

  document.getElementById("btnLoad").onclick = () => {
    const v = document.getElementById("spriteUrl").value.trim();
    if (v) {
      localStorage.setItem("spriteURL", v);
      trySources([v]);
    }
  };

  const spriteSelect = document.getElementById("spriteSelect");
  if (spriteSelect) {
    const current = localStorage.getItem("spriteURL") || urlInput.value;
    if (current) {
      for (const opt of spriteSelect.options) {
        if (opt.value === current) spriteSelect.value = current;
      }
    }
    spriteSelect.addEventListener("change", () => {
      const url = spriteSelect.value;
      localStorage.setItem("spriteURL", url);
      urlInput.value = url;
      trySources([url]);
    });
  }

  const fileInput=document.getElementById('fileInput');
  document.getElementById('btnFile').onclick=()=>fileInput.click();
  fileInput.onchange = () => {
    const f = fileInput.files && fileInput.files[0];
    if (!f) return;
    const url = URL.createObjectURL(f);
    currentObjectUrl = url;
    localStorage.setItem("spriteURL", url);
    trySources([url]);
  };

  const drop=document.getElementById('drop');
  ['dragenter','dragover'].forEach(ev=>addEventListener(ev,e=>{e.preventDefault(); drop.classList.add('show');}));
  ['dragleave','drop'].forEach(ev => addEventListener(ev, e => {
    e.preventDefault();
    if (ev === 'drop') {
      const f = e.dataTransfer.files && e.dataTransfer.files[0];
      if (f) {
        const url = URL.createObjectURL(f);
        currentObjectUrl = url;
        localStorage.setItem("spriteURL", url);
        trySources([url]);
      }
    }
    drop.classList.remove('show');
  }));

  // ===== Player, input, animation (3×4 locked) =====
  const player={
    x:200,
    y:200,
    speed:200,
    frame:1,
    dir:'down',
    tick:0,
    collider:{ w:24, h:28 },
    state:'idle',
    wasMoving:false,
    outlineColor:'#070b16',
    outlineThickness:1.5
  };
  const particles=[];
  const pressed=new Set();
  function normKey(k){ const map={Left:'ArrowLeft',Right:'ArrowRight',Up:'ArrowUp',Down:'ArrowDown'}; return map[k] || (k.length===1?k.toLowerCase():k); }
  // Global keybinds: WASD/arrow for movement, 'N' jumps to the next room.
  addEventListener('keydown',e=>{
    const k=normKey(e.key);
    if(k==='n'){
      if(!e.repeat){
        e.preventDefault();
        goToNextRoom();
      }
      return;
    }
    if(k.startsWith('Arrow')) e.preventDefault();
    pressed.add(k);
  });
  addEventListener('keyup',e=>{ const k=normKey(e.key); if(k.startsWith('Arrow')) e.preventDefault(); pressed.delete(k); });

  function frameRect(dir,frame){
    const row={down:0,left:1,right:2,up:3}[dir];
    const col=Math.max(0,Math.min(SHEET_COLS-1, frame));
    return { sx:col*frameW, sy:row*frameH, sw:frameW, sh:frameH };
  }

  function updatePlayerCollider(){
    // Shrink the collision box so the player feels responsive.
    player.collider.w=Math.max(18,Math.min(frameW*0.6, frameW));
    player.collider.h=Math.max(20,Math.min(frameH*0.7, frameH));
  }
  waitForSpriteReady().then(updatePlayerCollider);

  // ===== Camera setup =====
  camera={
    x:0,
    y:0,
    width:innerWidth,
    height:innerHeight,
    deadzone:{ width:360, height:220 }
  };

  function resizeCamera(){
    if(!camera) return;
    camera.width=innerWidth;
    camera.height=innerHeight;
  }
  resize();

  // ===== World data & loading =====
  const propSpriteCache=new Map();
  function requestPropSprite(url){
    if(!propSpriteCache.has(url)){
      const img=new Image();
      const entry={ img, ready:false, error:false };
      img.onload=()=>{ entry.ready=true; };
      img.onerror=()=>{ entry.error=true; };
      img.src=url;
      propSpriteCache.set(url,entry);
    }
    return propSpriteCache.get(url);
  }

  function createDefaultParallaxLayers(){
    return [
      { factor:0.1, type:'gradient', colors:['#0b1326','#0f172a'] },
      { factor:0.3, type:'hills', color:'#10203a', base:260, amplitude:90, spacing:420 },
      { factor:0.55, type:'hills', color:'#1a2f4f', base:320, amplitude:60, spacing:260 },
      { factor:0.85, type:'foreground', color:'#1f3b5f', height:160 }
    ];
  }

  const DEFAULT_WORLD={ width:1600, height:1200 };

  function cloneObstacles(list){
    return (list||[]).map(o=>({
      x:Number(o.x)||0,
      y:Number(o.y)||0,
      w:Number(o.w)||0,
      h:Number(o.h)||0,
      type:o.type||'wall'
    }));
  }

  function cloneProps(list){
    return (list||[]).map(p=>({
      x:Number(p.x)||0,
      y:Number(p.y)||0,
      w:Number(p.w)||32,
      h:Number(p.h)||32,
      color:p.color||'#94a3b8',
      spriteURL:p.spriteURL||null,
      sprite:null,
      shadow:typeof p.shadow==='boolean'?p.shadow:undefined,
      height:Number(p.height)||0,
      outlineColor:p.outlineColor||null,
      outlineThickness:typeof p.outlineThickness==='number'?p.outlineThickness:null,
      type:p.type||null,
      handleColor:p.handleColor||null,
      flameColor:p.flameColor||null,
      flameHighlight:p.flameHighlight||null,
      glowColor:p.glowColor||null,
      sconceColor:p.sconceColor||null,
      lightRadius:Number.isFinite(Number(p.lightRadius))?Number(p.lightRadius):null,
      lightIntensity:Number.isFinite(Number(p.lightIntensity))?Number(p.lightIntensity):null,
      lightOffsetY:Number.isFinite(Number(p.lightOffsetY))?Number(p.lightOffsetY):null
    }));
  }

  function deriveTorchLights(list){
    if(!Array.isArray(list)) return [];
    const lights=[];
    for(const prop of list){
      if(!prop || prop.type!=='torch') continue;
      const width=Math.max(0,Number(prop.w)||0);
      const height=Math.max(0,Number(prop.h)||0);
      const rawRadius=Number(prop.lightRadius);
      const rawIntensity=Number(prop.lightIntensity);
      const rawOffset=Number(prop.lightOffsetY);
      const radius=Number.isFinite(rawRadius)?Math.max(1,rawRadius):Math.max(160,height*3);
      const intensity=Number.isFinite(rawIntensity)?Math.max(0,Math.min(1,rawIntensity)):0.88;
      const offset=Math.max(0,Number.isFinite(rawOffset)?rawOffset:height*0.3);
      lights.push({
        x:prop.x+width/2,
        y:prop.y+offset,
        radius,
        intensity
      });
    }
    return lights;
  }

  // ----- Room definitions (edit/add rooms here) -----
  const rooms={
    room1:{
      spawn:{ x:320, y:360 },
      obstacles:[
        { x:180, y:200, w:420, h:48, type:'wall' },
        { x:680, y:420, w:96, h:180, type:'tree' },
        { x:520, y:620, w:260, h:56, type:'rock' }
      ],
      props:[
        { x:520, y:260, w:48, h:48, spriteURL:'assets/Male 18-1.png', shadow:true, height:24 },
        { x:860, y:480, w:40, h:40, color:'#64748b', shadow:true },
        // Example wall torches with automatic lighting
        { type:'torch', x:340, y:260, w:18, h:62, shadow:false, handleColor:'#6b3f1d', sconceColor:'#3f4d63', flameColor:'#fb923c', flameHighlight:'#fef3c7', glowColor:'rgba(253,224,171,0.4)', lightRadius:240, lightIntensity:0.9, lightOffsetY:24 },
        { type:'torch', x:820, y:260, w:18, h:62, shadow:false, handleColor:'#6b3f1d', sconceColor:'#3f4d63', flameColor:'#f97316', flameHighlight:'#fde68a', glowColor:'rgba(253,224,171,0.35)', lightRadius:240, lightIntensity:0.92, lightOffsetY:24 }
      ],
      lights:[
        { x:420, y:340, radius:280, intensity:0.85 },
        { x:760, y:500, radius:240, intensity:0.8 }
      ]
    },
    room2:{
      spawn:{ x:720, y:420 },
      obstacles:[
        { x:260, y:340, w:520, h:60, type:'wall' },
        { x:940, y:360, w:140, h:220, type:'tree' },
        { x:540, y:740, w:360, h:70, type:'rock' }
      ],
      props:[
        { x:600, y:520, w:60, h:60, color:'#475569', shadow:true },
        { x:1040, y:360, w:96, h:96, spriteURL:'assets/Male 18-1.png', shadow:true, height:36 },
        // Torches flank the entrance in this room as well
        { type:'torch', x:520, y:320, w:18, h:60, shadow:false, handleColor:'#6b3f1d', sconceColor:'#3f4d63', flameColor:'#fb923c', flameHighlight:'#fef3c7', glowColor:'rgba(253,224,171,0.38)', lightRadius:220, lightIntensity:0.88, lightOffsetY:22 },
        { type:'torch', x:980, y:320, w:18, h:60, shadow:false, handleColor:'#6b3f1d', sconceColor:'#3f4d63', flameColor:'#f97316', flameHighlight:'#fde68a', glowColor:'rgba(253,224,171,0.34)', lightRadius:220, lightIntensity:0.9, lightOffsetY:22 }
      ],
      lights:[
        { x:720, y:400, radius:260, intensity:0.9 },
        { x:1080, y:360, radius:220, intensity:0.7 }
      ]
    }
  };

  const roomNames=Object.keys(rooms);
  let currentRoomIndex=0;

  // Loader entry point: pass in a plain JS room object (e.g., parsed JSON).
  function loadRoom(roomData){
    if(!roomData) return;

    // Cache spawn so we can position the player before starting the loop.
    const spawn={
      x:Number(roomData.spawn?.x) || 0,
      y:Number(roomData.spawn?.y) || 0
    };

    // Clear old state and copy in the new room geometry.
    currentObstacles.length=0;
    currentProps.length=0;
    currentObstacles.push(...cloneObstacles(roomData.obstacles));

    const props=cloneProps(roomData.props);
    for(const prop of props){
      if(prop.spriteURL){
        prop.sprite=requestPropSprite(prop.spriteURL);
      }
      currentProps.push(prop);
    }

    currentParallaxLayers = roomData.parallaxLayers?.length
      ? roomData.parallaxLayers.map(layer=>({ ...layer }))
      : createDefaultParallaxLayers();

    const baseLights=Array.isArray(roomData.lights)?roomData.lights:[];
    const torchLights=deriveTorchLights(currentProps); // auto lights for torches
    setLights([...baseLights,...torchLights]);

    currentRoom={
      name:roomData.name || '',
      spawn,
      obstacles:currentObstacles,
      props:currentProps,
      world:{
        width:roomData.world?.width ?? DEFAULT_WORLD.width,
        height:roomData.world?.height ?? DEFAULT_WORLD.height
      },
      parallaxLayers:currentParallaxLayers,
      lights:Graphics.lights
    };

    // Move the player to the new spawn and recentre the camera.
    player.x=spawn.x;
    player.y=spawn.y;
    player.frame=1;
    player.tick=0;
    clampPlayerToWorld();
    resetCameraToPlayer();
  }

  function goToRoom(index){
    if(!roomNames.length) return;
    currentRoomIndex=((index%roomNames.length)+roomNames.length)%roomNames.length;
    const roomName=roomNames[currentRoomIndex];
    loadRoom(rooms[roomName]);
    showNotice(`Entered ${roomName}`);
  }

  function goToNextRoom(){
    // Keyboard shortcut uses this to advance to the next room in the list.
    goToRoom(currentRoomIndex+1);
  }

  function getActiveWorld(){ return currentRoom?.world ?? DEFAULT_WORLD; }
  function getObstacles(){ return currentObstacles; }
  function getProps(){ return currentProps; }
  function getParallaxLayers(){ return currentParallaxLayers.length ? currentParallaxLayers : createDefaultParallaxLayers(); }

  function clampPlayerToWorld(){
    const world=getActiveWorld();
    const halfW=player.collider.w/2;
    const halfH=player.collider.h/2;
    player.x=Math.min(Math.max(player.x, halfW), world.width-halfW);
    player.y=Math.min(Math.max(player.y, halfH), world.height-halfH);
  }

  function resetCameraToPlayer(){
    const world=getActiveWorld();
    camera.x=player.x-camera.width/2;
    camera.y=player.y-camera.height/2;
    clampCameraToWorld();
  }

  // Load the initial room before starting the game loop
  goToRoom(0);

  // ===== Collision helpers =====
  function rectsOverlap(a,b){
    return a.left < b.x + b.w && a.right > b.x && a.top < b.y + b.h && a.bottom > b.y;
  }

  function isRectVisible(rect){
    return rect.x + rect.w > camera.x && rect.x < camera.x + camera.width && rect.y + rect.h > camera.y && rect.y < camera.y + camera.height;
  }

  function clampCameraToWorld(){
    const world=getActiveWorld();
    const maxX=Math.max(0, world.width-camera.width);
    const maxY=Math.max(0, world.height-camera.height);
    camera.x=Math.min(Math.max(camera.x,0), maxX);
    camera.y=Math.min(Math.max(camera.y,0), maxY);
  }

  function updateCamera(){
    // Camera follows the player only when they leave a centered deadzone.
    // We measure the player's distance from the deadzone edges and shift the
    // camera just enough to bring them back inside, which prevents jitter.
    const halfDeadW=camera.deadzone.width/2;
    const halfDeadH=camera.deadzone.height/2;
    const deadLeft=camera.x + camera.width/2 - halfDeadW;
    const deadRight=camera.x + camera.width/2 + halfDeadW;
    const deadTop=camera.y + camera.height/2 - halfDeadH;
    const deadBottom=camera.y + camera.height/2 + halfDeadH;

    if(player.x < deadLeft){ camera.x += player.x - deadLeft; }
    else if(player.x > deadRight){ camera.x += player.x - deadRight; }

    if(player.y < deadTop){ camera.y += player.y - deadTop; }
    else if(player.y > deadBottom){ camera.y += player.y - deadBottom; }

    clampCameraToWorld();
  }

  function tryMove(axis, amount, obstacles){
    // Axis-aligned collision resolution: move along one axis, clamp against
    // colliders, then move along the other axis. This produces natural
    // "sliding" when hitting corners because the non-blocked axis still moves.
    if(amount===0) return;
    const halfW=player.collider.w/2;
    const halfH=player.collider.h/2;
    if(axis==='x'){
      let newX=player.x+amount;
      const rect={ left:newX-halfW, right:newX+halfW, top:player.y-halfH, bottom:player.y+halfH };
      for(const ob of obstacles){
        if(!rectsOverlap(rect,{ x:ob.x, y:ob.y, w:ob.w, h:ob.h })) continue;
        if(amount>0){ newX=ob.x-halfW; rect.left=newX-halfW; rect.right=newX+halfW; }
        else { newX=ob.x+ob.w+halfW; rect.left=newX-halfW; rect.right=newX+halfW; }
      }
      player.x=newX;
    } else if(axis==='y'){
      let newY=player.y+amount;
      const rect={ left:player.x-halfW, right:player.x+halfW, top:newY-halfH, bottom:newY+halfH };
      for(const ob of obstacles){
        if(!rectsOverlap(rect,{ x:ob.x, y:ob.y, w:ob.w, h:ob.h })) continue;
        if(amount>0){ newY=ob.y-halfH; rect.top=newY-halfH; rect.bottom=newY+halfH; }
        else { newY=ob.y+ob.h+halfH; rect.top=newY-halfH; rect.bottom=newY+halfH; }
      }
      player.y=newY;
    }
  }

  function update(dt){
    const obstacles=getObstacles();
    let dx=0,dy=0;
    if(pressed.has('ArrowUp')||pressed.has('w')){ dy-=1; player.dir='up'; }
    if(pressed.has('ArrowDown')||pressed.has('s')){ dy+=1; player.dir='down'; }
    if(pressed.has('ArrowLeft')||pressed.has('a')){ dx-=1; player.dir='left'; }
    if(pressed.has('ArrowRight')||pressed.has('d')){ dx+=1; player.dir='right'; }

    const len=Math.hypot(dx,dy);
    if(len>0){ dx/=len; dy/=len; }

    const moveX=dx*player.speed*dt;
    const moveY=dy*player.speed*dt;
    const isMoving=Math.abs(moveX)>0.001 || Math.abs(moveY)>0.001;
    player.state=isMoving?'run':'idle';
    if(isMoving && !player.wasMoving){
      spawnDustBurst(4,dx,dy);
    } else if(!isMoving && player.wasMoving){
      spawnDustBurst(3,0,0);
    }
    player.wasMoving=isMoving;

    tryMove('x',moveX,obstacles);
    clampPlayerToWorld();
    tryMove('y',moveY,obstacles);
    clampPlayerToWorld();

    if(isMoving){
      player.tick+=dt;
      if(player.tick>0.18){ player.frame=(player.frame+1)%SHEET_COLS; player.tick=0; }
    } else {
      player.frame=1;
      player.tick=0;
    }

    updateCamera();
    updateParticles(dt);
  }

  function drawParallaxLayers(){
    const g=Graphics.sceneCtx;
    const layers=getParallaxLayers();

    g.clearRect(0,0,camera.width,camera.height);

    const sky=g.createLinearGradient(0,0,0,camera.height);
    sky.addColorStop(0,'#0b1326');
    sky.addColorStop(1,'#0b1020');
    g.fillStyle=sky;
    g.fillRect(0,0,camera.width,camera.height);

    for(const layer of layers){
      const factor=layer.factor ?? 0.5;
      const offsetX=(camera.x*factor)% (layer.spacing||camera.width);
      const offsetY=(camera.y*factor)% (layer.spacing||camera.height);
      if(layer.type==='gradient'){
        const grad=g.createLinearGradient(0,0,0,camera.height);
        grad.addColorStop(0,layer.colors?.[0]||'#0b1326');
        grad.addColorStop(1,layer.colors?.[1]||'#111827');
        g.fillStyle=grad;
        g.fillRect(0,0,camera.width,camera.height);
        continue;
      }
      if(layer.type==='hills'){
        const spacing=layer.spacing||320;
        const amplitude=layer.amplitude||60;
        const base=layer.base||300;
        const startX=-spacing*2 - offsetX;
        const endX=camera.width+spacing*2;
        g.fillStyle=layer.color||'#1e293b';
        for(let x=startX; x<endX; x+=spacing){
          const peakX=x+spacing/2;
          g.beginPath();
          g.moveTo(x, camera.height - base + offsetY);
          g.quadraticCurveTo(peakX, camera.height - (base+amplitude) + offsetY, x+spacing, camera.height - base + offsetY);
          g.lineTo(x+spacing, camera.height+20);
          g.lineTo(x, camera.height+20);
          g.closePath();
          g.fill();
        }
        continue;
      }
      if(layer.type==='foreground'){
        g.fillStyle=layer.color||'#1f3b5f';
        g.fillRect(-offsetX, camera.height-(layer.height||140)+offsetY, camera.width+(layer.spacing||camera.width)*2, (layer.height||140)+40);
        continue;
      }
    }
  }

  const OBSTACLE_COLORS={
    rock:'#475569',
    tree:'#334155',
    wall:'#64748b',
    default:'#4b5563'
  };

  function drawObstacle(ob){
    const g=Graphics.sceneCtx;
    const screenX=snapPixel(ob.x-camera.x);
    const screenY=snapPixel(ob.y-camera.y);
    g.fillStyle=OBSTACLE_COLORS[ob.type] || OBSTACLE_COLORS.default;
    g.fillRect(screenX,screenY,ob.w,ob.h);
    g.strokeStyle='rgba(8,12,20,0.65)';
    g.lineWidth=1;
    g.strokeRect(screenX+0.5,screenY+0.5,ob.w-1,ob.h-1);
  }

  function drawTorchProp(prop,x,y,outlineColor,outlineThickness){
    const g=Graphics.sceneCtx;
    const width=Math.max(6,prop.w||16);
    const height=Math.max(24,prop.h||48);
    const flameHeight=Math.max(10,height*0.4);
    const stemHeight=Math.max(8,height-flameHeight);
    const stemWidth=Math.max(4,Math.min(width*0.4,width-4));
    const baseHeight=Math.min(stemHeight,Math.max(4,stemHeight*0.25));
    const baseWidth=Math.min(width,Math.max(stemWidth*1.4,width*0.75));
    const baseX=x+(width-baseWidth)/2;
    const baseY=y+flameHeight+stemHeight-baseHeight;
    const stemX=x+(width-stemWidth)/2;
    const stemY=y+flameHeight;
    const handleColor=prop.handleColor||'#5b341b';
    const sconceColor=prop.sconceColor||'#475569';

    drawOutlinedRect(g,baseX,baseY,baseWidth,baseHeight,sconceColor,outlineColor,outlineThickness);
    drawOutlinedRect(g,stemX,stemY,stemWidth,stemHeight,handleColor,outlineColor,outlineThickness);

    const flameWidth=Math.min(width,Math.max(stemWidth*1.6,width*0.85));
    const flameX=x+(width-flameWidth)/2;
    const flameY=y+Math.max(0,flameHeight*0.05);
    const flameTopColor=prop.flameHighlight||'#fde68a';
    const flameBottomColor=prop.flameColor||'#f97316';

    g.save();
    const gradient=g.createLinearGradient(flameX,flameY,flameX,flameY+flameHeight);
    gradient.addColorStop(0,flameTopColor);
    gradient.addColorStop(1,flameBottomColor);
    g.fillStyle=gradient;
    g.beginPath();
    g.moveTo(flameX+flameWidth/2,flameY);
    g.bezierCurveTo(flameX,flameY+flameHeight*0.55,flameX+flameWidth*0.2,flameY+flameHeight,flameX+flameWidth/2,flameY+flameHeight);
    g.bezierCurveTo(flameX+flameWidth*0.8,flameY+flameHeight,flameX+flameWidth,flameY+flameHeight*0.55,flameX+flameWidth/2,flameY);
    g.closePath();
    g.fill();
    g.restore();

    g.save();
    g.fillStyle='rgba(255,255,255,0.45)';
    g.beginPath();
    g.ellipse(flameX+flameWidth/2,flameY+flameHeight*0.3,flameWidth*0.22,flameHeight*0.35,0,0,Math.PI*2);
    g.fill();
    g.restore();

    g.save();
    g.globalCompositeOperation='lighter';
    g.fillStyle=prop.glowColor||'rgba(251,191,36,0.4)';
    g.beginPath();
    g.ellipse(flameX+flameWidth/2,flameY+flameHeight*0.45,flameWidth*0.9,flameHeight*1.05,0,0,Math.PI*2);
    g.fill();
    g.restore();
  }

  function drawProp(prop){
    const g=Graphics.sceneCtx;
    const x=snapPixel(prop.x-camera.x);
    const y=snapPixel(prop.y-camera.y);
    const outlineColor=prop.outlineColor ?? Graphics.outlineColor;
    const outlineThickness=prop.outlineThickness ?? Graphics.outlineThickness;

    if(prop.type==='torch'){
      drawTorchProp(prop,x,y,outlineColor,outlineThickness);
      return;
    }

    if((prop.shadow ?? prop.height>0)){
      const baseX=x+prop.w/2;
      const baseY=y+prop.h;
      const radiusX=Math.max(6,prop.w*0.45);
      const radiusY=Math.max(3,(prop.height||prop.h*0.25)*0.25);
      g.save();
      g.fillStyle='rgba(10,12,20,0.4)';
      g.beginPath();
      g.ellipse(baseX,baseY,radiusX,radiusY,0,0,Math.PI*2);
      g.fill();
      g.restore();
    }
    const spriteEntry=prop.sprite;
    if(spriteEntry && spriteEntry.ready){
      drawOutlinedSprite(g,spriteEntry.img,0,0,spriteEntry.img.width,spriteEntry.img.height,x,y,prop.w,prop.h,outlineColor,outlineThickness);
    } else {
      drawOutlinedRect(g,x,y,prop.w,prop.h,prop.color||'#94a3b8',outlineColor,outlineThickness);
      if(spriteEntry && spriteEntry.error){
        g.strokeStyle='#ef4444';
        g.beginPath();
        g.moveTo(x+4,y+4);
        g.lineTo(x+prop.w-4,y+prop.h-4);
        g.moveTo(x+prop.w-4,y+4);
        g.lineTo(x+4,y+prop.h-4);
        g.stroke();
      }
    }
  }

  function drawPlayer(){
    const g=Graphics.sceneCtx;
    const px=player.x-camera.x;
    const py=player.y-camera.y;
    if(spriteReady){
      const {sx,sy,sw,sh}=frameRect(player.dir,player.frame);
      const destX=px-sw/2;
      const destY=py-sh/2;
      drawOutlinedSprite(g,sprite,sx,sy,sw,sh,destX,destY,sw,sh,player.outlineColor||Graphics.outlineColor,player.outlineThickness||Graphics.outlineThickness);
    } else {
      drawOutlinedRect(g,px-16,py-16,32,32,'#e5e7eb');
    }
  }

  // ===== Particle effects (dust puffs on acceleration/braking) =====
  function spawnDustBurst(count=3,dirX=0,dirY=0){
    const originX=player.x;
    const originY=player.y + (player.collider?.h||24)*0.35;
    for(let i=0;i<count;i++){
      const angle=Math.random()*Math.PI*2;
      const speed=30+Math.random()*50;
      const vx=Math.cos(angle)*speed + dirX*30;
      const vy=Math.sin(angle)*speed + dirY*30;
      particles.push({
        x:originX+(Math.random()-0.5)*6,
        y:originY+(Math.random()-0.5)*4,
        vx,
        vy,
        life:0,
        maxLife:0.35+Math.random()*0.2,
        size:2.2+Math.random()*1.6
      });
    }
  }

  function updateParticles(dt){
    for(let i=particles.length-1;i>=0;i--){
      const p=particles[i];
      p.life+=dt;
      if(p.life>=p.maxLife){
        particles.splice(i,1);
        continue;
      }
      p.x+=p.vx*dt;
      p.y+=p.vy*dt;
      p.vx*=0.85;
      p.vy*=0.85;
    }
  }

  function drawParticles(){
    if(!particles.length) return;
    const g=Graphics.sceneCtx;
    g.save();
    g.globalCompositeOperation='lighter';
    for(const p of particles){
      const progress=p.life/p.maxLife;
      const alpha=Math.max(0,0.55-progress*0.55);
      if(alpha<=0) continue;
      const screenX=p.x-camera.x;
      const screenY=p.y-camera.y;
      if(screenX<-20 || screenX>camera.width+20 || screenY<-20 || screenY>camera.height+20) continue;
      const size=p.size*(1+progress*0.4);
      g.fillStyle=`rgba(205,214,230,${alpha})`;
      g.beginPath();
      g.ellipse(screenX,screenY,size,size*0.6,0,0,Math.PI*2);
      g.fill();
    }
    g.restore();
  }

  function drawWorld(){
    const drawList=[];
    for(const ob of getObstacles()){
      if(!isRectVisible(ob)) continue;
      drawList.push({ type:'obstacle', y:ob.y+ob.h, data:ob });
    }
    for(const prop of getProps()){
      if(!isRectVisible(prop)) continue;
      drawList.push({ type:'prop', y:prop.y+prop.h, data:prop });
    }
    drawList.sort((a,b)=>a.y-b.y);
    for(const item of drawList){
      if(item.type==='obstacle') drawObstacle(item.data);
      else drawProp(item.data);
    }
    drawPlayer();
  }

  // ===== Toon lighting pass =====
  function celLighting(){
    const g=Graphics.sceneCtx;
    const lctx=Graphics.lightingCtx;
    const width=camera.width;
    const height=camera.height;
    const ambient=Math.max(0,Math.min(1,Graphics.ambientDarkness));
    const ambientBrightness=1-ambient;
    const baseChannel=Math.round(ambientBrightness*255);
    const toneSource=(Array.isArray(Graphics.toneLevels) && Graphics.toneLevels.length)
      ? Graphics.toneLevels
      : DEFAULT_TONE_LEVELS;
    const toneLevels=toneSource.slice().sort((a,b)=>a-b);
    const bandCount=toneLevels.length||1;

    lctx.save();
    lctx.globalCompositeOperation='source-over';
    lctx.clearRect(0,0,width,height);
    lctx.fillStyle=`rgb(${baseChannel},${baseChannel},${baseChannel})`;
    lctx.fillRect(0,0,width,height);

    const activeLights=[];
    if(Array.isArray(Graphics.lights)) activeLights.push(...Graphics.lights);
    if(Graphics.playerLightEnabled){
      activeLights.push({
        x:player.x,
        y:player.y+(player.collider?.h||0)*0.35,
        radius:Graphics.playerLightRadius,
        intensity:Graphics.playerLightIntensity
      });
    }

    for(const light of activeLights){
      const radius=Math.max(4,Number(light.radius)||0);
      const intensity=Math.max(0,Math.min(1,Number(light.intensity ?? 1)));
      if(intensity<=0 || radius<=0) continue;
      const cx=light.x-camera.x;
      const cy=light.y-camera.y;
      if(cx+radius< -100 || cy+radius< -100 || cx-radius>width+100 || cy-radius>height+100) continue;
      const centerX=snapPixel(cx);
      const centerY=snapPixel(cy);
      for(let i=0;i<toneLevels.length;i++){
        const level=Math.max(0,Math.min(1,toneLevels[i]));
        const ratio=(bandCount-i)/bandCount;
        let bandRadius=radius*ratio;
        if(Graphics.pixelArtMode) bandRadius=Math.max(1,Math.round(bandRadius));
        if(bandRadius<=0) continue;
        const brightness=ambientBrightness + (1-ambientBrightness)*level*intensity;
        const channel=Math.round(Math.max(ambientBrightness,Math.min(1,brightness))*255);
        lctx.beginPath();
        lctx.arc(centerX,centerY,bandRadius,0,Math.PI*2);
        lctx.closePath();
        lctx.fillStyle=`rgb(${channel},${channel},${channel})`;
        lctx.fill();
      }
    }
    lctx.restore();

    g.save();
    g.globalCompositeOperation='multiply';
    g.drawImage(Graphics.lightingCanvas,0,0,width,height);
    g.restore();
    g.globalCompositeOperation='source-over';
  }

  function draw(){
    drawParallaxLayers();
    drawWorld();
    drawParticles();
    celLighting();

    ctx.save();
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,gameC.width,gameC.height);
    ctx.drawImage(Graphics.sceneCanvas,0,0,Graphics.sceneCanvas.width,Graphics.sceneCanvas.height,0,0,gameC.width,gameC.height);
    ctx.restore();
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }

  let last=0;
  function loop(now){
    const dt=Math.min(0.033,(now-last)/1000);
    last=now;
    update(dt);
    draw();
    requestAnimationFrame(loop);
  }

  async function startGameLoop(){
    await initialSpritePromise;
    updatePlayerCollider();
    last=performance.now();
    requestAnimationFrame(loop);
  }
  startGameLoop();

  // ===== Tests (keep existing and add a few more) =====
  const results=[]; function assert(name,cond){ results.push({name,pass:!!cond}); if(!cond) console.error('[TEST FAIL]',name); }
  function runTests(){
    assert('frame cell width > 0', frameW>0);
    assert('frame cell height > 0', frameH>0);
    const r0=frameRect('down',0); assert('frameRect sx >= 0', r0.sx>=0);
    const r1=frameRect('up',2); assert('frameRect sy for up row correct', r1.sy===frameH*3);
    if(spriteReady){
      assert('3 columns detected', Math.round(sprite.naturalWidth / frameW) === SHEET_COLS);
      assert('4 rows detected', Math.round(sprite.naturalHeight / frameH) === SHEET_ROWS);
    }
    const rL = frameRect('left',2); assert('left row index', rL.sy===frameH*1);
    const rR = frameRect('right',2); assert('right row index', rR.sy===frameH*2);
    const roomAfterLoad=currentRoom;
    assert('room loaded', !!roomAfterLoad);
    assert('spawn applied to player', Math.round(player.x)===Math.round(roomAfterLoad.spawn.x));
    console.log(results);
  }
  setTimeout(runTests,2200);
  </script>
</body>
</html>
